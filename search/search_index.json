{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Algorithmics (\u6f14\u7b97\u6cd5) 2022","text":"<p>The Quantum Computing I have learned in Algorithms 2022 Spring | Dr. Jehn-Ruey Jiang (\u6c5f\u632f\u745e\uff09</p> <p>\u8072\u660e\uff1a\u6b64 repo \u7d55\u5c0d\u4e0d\u6703\u76c8\u5229\uff0c\u90fd\u662f\u8ab2\u7a0b\u4e0a\u6240\u5b78\u5230\u7684\uff0c\u4e5f\u4e0d\u6703\u60e1\u610f\u50b3\u64ad\uff0c\u4e00\u5207\u90fd\u6703\u4ee5\u6559\u6388\u6307\u5c0e\u70ba\u539f\u5247\u3002</p>"},{"location":"contributing/","title":"Contributing.md","text":""},{"location":"reference/","title":"Reference","text":"<ul> <li>2022 \u8ab2\u7a0b\u7db2\u9801\uff1aAlgorithmics (\u6f14\u7b97\u6cd5) 2022</li> <li>2023 \u8ab2\u7a0b\u7db2\u9801\uff1aAlgorithmics (\u6f14\u7b97\u6cd5) 2023</li> <li>\u6559\u6388\u7db2\u9801\uff1aJehn-Ruey Jiang (\u6c5f\u632f\u745e</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#build-environment","title":"Build Environment","text":"<pre><code>pip3 install virtualenv\nvirtualenv venv --python=python3.9\nsource venv/bin/activate\npip install -r requirements.txt\ndeactivate\nrm -rf venv     # remove the venv\n</code></pre>"},{"location":"black_box/","title":"Algorithmics (\u6f14\u7b97\u6cd5) 2022 - Midterm Project","text":""},{"location":"black_box/#tags-quantum-computing-black-box-algorithmics-uni-project-deutsch","title":"Tags: <code>Quantum-Computing</code>, <code>black-box</code>, <code>Algorithmics</code>, <code>uni-project</code>, <code>Deutsch</code>","text":"<p>Course: CE3005 - Algorithmics Dept: ATM Name: Hugo ChunHo Lin Student Number: 109601003</p> <p>Programming Deutsch Algorithm and Running it on a Quantum Computer Simulator or a Real IBM Q Computer (\u8acb\u53c3\u8003\u7df4\u7fd2 5.5)</p>"},{"location":"black_box/#pre-analyzing","title":"pre-analyzing","text":""},{"location":"black_box/#four-statuses","title":"Four statuses","text":""},{"location":"black_box/#constant-output-equal-0","title":"Constant: Output equal 0.","text":"<p>\u6b32\u4f7f\u4efb\u4f55\u8f38\u5165\uff08q0\u4e0d\u8ad6\u662f0\u62161\uff09\u81f3\u51fd\u6578\u4e2d\u4e14\u5168\u90e8\u7d50\u679c\uff08q1\uff09\u70ba0\uff0c\u4e5f\u5c31\u4ee3\u8868q1\u4e4b\u503c\u4e0d\u6703\u53d7q0\u6240\u5f71\u97ff\uff0c\u6240\u4ee5\u795e\u8aed\uff08Oracle\uff09\u9078\u7528I\u9598\uff0c\u5982\u6b64q1\u4fbf\u4e0d\u53d7q0\u5f71\u97ff\uff0c\u4e14\u5f9e\u91cf\u5b50\u96fb\u8166\u6a21\u64ec\u4ee5\u53ca\u91cf\u5b50\u96fb\u8166\u7684\u57f7\u884c\u7d50\u679c\uff0c\u7d50\u679c\u70ba |0&gt; \u7684\u6a5f\u7387\u90fd\u63a5\u8fd1100%\uff1b|1&gt; \u7684\u6a5f\u7387\u90fd\u63a5\u8fd10%\uff0c\u56e0\u6b64\u6b64\u9ed1\u7bb1\u51fd\u6578\u70ba\u5e38\u6578\u51fd\u6578\u3002</p> What I have done Plot Display Create quantum circuit prove through histogram. Also prove in IBM Q Computer."},{"location":"black_box/#constant-output-equal-1","title":"Constant: Output equal 1","text":"<p>\u6b32\u4f7f\u4efb\u4f55\u8f38\u5165\uff08q0\u4e0d\u8ad6\u662f0\u62161\uff09\u81f3\u51fd\u6578\u4e2d\u4e14\u5168\u90e8\u7d50\u679c\uff08q1\uff09\u70ba1\uff0c\u4e5f\u5c31\u4ee3\u8868q1\u4e4b\u503c\u4e0d\u6703\u53d7q0\u6240\u5f71\u97ff\uff0c\u6240\u4ee5\u795e\u8aed\uff08Oracle\uff09\u9078\u7528X\u9598\uff0c\u5982\u6b64q1\u4fbf\u4e0d\u53d7q0\u5f71\u97ff\uff0c\u4e26\u4e14\u5168\u90fd\u6703\u8b8a\u62101\uff0c\u4e14\u5f9e\u91cf\u5b50\u96fb\u8166\u6a21\u64ec\u4ee5\u53ca\u91cf\u5b50\u96fb\u8166\u7684\u57f7\u884c\u7d50\u679c\uff0c\u7d50\u679c\u70ba |0&gt; \u7684\u6a5f\u7387\u90fd\u63a5\u8fd1100%\uff1b|1&gt; \u7684\u6a5f\u7387\u90fd\u63a5\u8fd10%\uff0c\u56e0\u6b64\u6b64\u9ed1\u7bb1\u51fd\u6578\u70ba\u5e38\u6578\u51fd\u6578\u3002</p> What I have done Plot Display Create quantum circuit prove through histogram. Also prove in IBM Q Computer."},{"location":"black_box/#balanced-input-equal-output","title":"Balanced: Input equal Output.","text":"<p>\u6b32\u4f7f\u51fd\u6578\u70ba\u5e73\u8861\u51fd\u6578\uff0c\u56e0\u800c\u6311\u9078CNOT\u9598\uff0c\u4e26\u4e14\u8b93q0\u70ba\u63a7\u5236\u4f4d\u5143\uff1bq1\u70ba\u76ee\u6a19\u4f4d\u5143\uff0c\u7576\u555f\u52d5CNOT\u9598\u6642\uff0cq1\u6703\u5f9e0\u8f49\u81f31\uff1b\u4e0d\u555f\u52d5CNOT\u9598\u6642\uff0cq1\u6703\u5f9e1\u8f49\u81f30\uff1b\u9032\u800c\u505a\u51fa\u8f38\u51fa\u8207\u8f38\u5165\u76f8\u7b49\uff0c\u4e14\u5f9e\u91cf\u5b50\u96fb\u8166\u6a21\u64ec\u4ee5\u53ca\u91cf\u5b50\u96fb\u8166\u7684\u57f7\u884c\u7d50\u679c\uff0c\u7d50\u679c\u70ba |1&gt; \u7684\u6a5f\u7387\u90fd\u63a5\u8fd1100%\uff1b|0&gt; \u7684\u6a5f\u7387\u90fd\u63a5\u8fd10%\uff0c\u56e0\u6b64\u6b64\u9ed1\u7bb1\u51fd\u6578\u70ba\u5e73\u8861\u51fd\u6578\u3002</p> What I have done Plot Display Create quantum circuit prove through histogram. Also prove in IBM Q Computer."},{"location":"black_box/#balanced-input-not-equal-output","title":"Balanced: Input not equal Output.","text":"<p>\u6b32\u4f7f\u51fd\u6578\u70ba\u5e73\u8861\u51fd\u6578\uff0c\u56e0\u800c\u6311\u9078CNOT\u9598\uff0c\u4e26\u4e14\u8b93q0\u70ba\u63a7\u5236\u4f4d\u5143\uff1bq1\u70ba\u76ee\u6a19\u4f4d\u5143\uff0c\u4f46\u662f\u7576\u555f\u52d5CNOT\u9598\u524d\uff0cq1\u6703\u5148\u7d93\u904eX\u9598\u6240\u4ee5\u6240\u4ee5q1\u6703\u5148\u7d93\u904e\u8f49\u81f3\uff0cq1\u6703\u5f9e0\u8f49\u81f31\uff1b1\u8f49\u81f30\uff0c\u63a5\u8457\u900f\u904eCNOT\u9598\uff0c\u9032\u800c\u505a\u51fa\u8f38\u51fa\u8207\u8f38\u5165\u76f8\u53cd\uff0c\u4e14\u5f9e\u91cf\u5b50\u96fb\u8166\u6a21\u64ec\u4ee5\u53ca\u91cf\u5b50\u96fb\u8166\u7684\u57f7\u884c\u7d50\u679c\uff0c\u7d50\u679c\u70ba |1&gt; \u7684\u6a5f\u7387\u90fd\u63a5\u8fd1100%\uff1b|0&gt; \u7684\u6a5f\u7387\u90fd\u63a5\u8fd10%\uff0c\u56e0\u6b64\u6b64\u9ed1\u7bb1\u51fd\u6578\u70ba\u5e73\u8861\u51fd\u6578\u3002</p> What I have done Plot Display Create quantum circuit prove through histogram. Also prove in IBM Q Computer."},{"location":"black_box/#reference","title":"Reference","text":"<ul> <li>Introduction to quantum computing: The Deutsch algorithm.</li> </ul>"},{"location":"black_box/balanced_in_eq_out/","title":"Balanced: Input equal Output.","text":"<p>Create the quantum Circuit.</p> In\u00a0[1]: Copied! <pre>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n\nqrx = QuantumRegister(1, 'q0')\nqry = QuantumRegister(1, 'q1')\ncr = ClassicalRegister(1, 'c')\n\nqc = QuantumCircuit(qrx, qry, cr)\nqc.h(qrx)\nqc.x(qry)\nqc.h(qry)\nqc.barrier()\nqc.cx(qrx, qry)\nqc.barrier()\nqc.h(qrx)\nqc.h(qry)\nqc.measure(qrx, cr)\nqc.draw(\"mpl\")\n</pre> from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister  qrx = QuantumRegister(1, 'q0') qry = QuantumRegister(1, 'q1') cr = ClassicalRegister(1, 'c')  qc = QuantumCircuit(qrx, qry, cr) qc.h(qrx) qc.x(qry) qc.h(qry) qc.barrier() qc.cx(qrx, qry) qc.barrier() qc.h(qrx) qc.h(qry) qc.measure(qrx, cr) qc.draw(\"mpl\") Out[1]: <p>Proof through histogram.</p> In\u00a0[2]: Copied! <pre>from qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\n\nsim = AerSimulator()\njob = execute(qc, backend = sim, shots = 1000)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Counts: \", counts)\nplot_histogram(counts)\n</pre> from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram  sim = AerSimulator() job = execute(qc, backend = sim, shots = 1000) result = job.result() counts = result.get_counts(qc) print(\"Counts: \", counts) plot_histogram(counts) <pre>Counts:  {'1': 1000}\n</pre> Out[2]: <p>Also in Quantum Computer.</p> In\u00a0[3]: Copied! <pre>from qiskit import QuantumCircuit, IBMQ, execute \nfrom qiskit.tools.monitor import job_monitor\nfrom qiskit.visualization import plot_histogram\n\nIBMQ.save_account('your_token')\nIBMQ.load_account()\nIBMQ.providers()\nprovider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')\nqcomp = provider.get_backend('ibmq_manila')\njob = execute(qc, backend = qcomp, shots = 1000)\njob_monitor(job)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\", counts)\nplot_histogram(counts)\n</pre> from qiskit import QuantumCircuit, IBMQ, execute  from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram  IBMQ.save_account('your_token') IBMQ.load_account() IBMQ.providers() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') qcomp = provider.get_backend('ibmq_manila') job = execute(qc, backend = qcomp, shots = 1000) job_monitor(job) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\", counts) plot_histogram(counts) <pre>/tmp/ipykernel_1918/811856264.py:5: DeprecationWarning: The package qiskit.providers.ibmq is being deprecated. Please see https://ibm.biz/provider_migration_guide to get instructions on how to migrate to qiskit-ibm-provider (https://github.com/Qiskit/qiskit-ibm-provider) and qiskit-ibm-runtime (https://github.com/Qiskit/qiskit-ibm-runtime).\n  IBMQ.save_account('your_token')\n/tmp/ipykernel_1918/811856264.py:5: DeprecationWarning: The qiskit.IBMQ entrypoint and the qiskit-ibmq-provider package (accessible from 'qiskit.providers.ibmq`) are deprecated and will be removed in a future release. Instead you should use the qiskit-ibm-provider package which is accessible from 'qiskit_ibm_provider'. You can install it with 'pip install qiskit_ibm_provider'. Just replace 'qiskit.IBMQ' with 'qiskit_ibm_provider.IBMProvider'\n  IBMQ.save_account('your_token')\n</pre> <pre>\n---------------------------------------------------------------------------\nHTTPError                                 Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:278, in RetrySession.request(self, method, url, bare, **kwargs)\n    277     response = super().request(method, final_url, headers=headers, **kwargs)\n--&gt; 278     response.raise_for_status()\n    279 except RequestException as ex:\n    280     # Wrap the requests exceptions into a IBM Q custom one, for\n    281     # compatibility.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/models.py:1021, in Response.raise_for_status(self)\n   1020 if http_error_msg:\n-&gt; 1021     raise HTTPError(http_error_msg, response=self)\n\nHTTPError: 401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken\n\nThe above exception was the direct cause of the following exception:\n\nRequestsApiError                          Traceback (most recent call last)\nCell In[3], line 6\n      3 from qiskit.visualization import plot_histogram\n      5 IBMQ.save_account('your_token')\n----&gt; 6 IBMQ.load_account()\n      7 IBMQ.providers()\n      8 provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:191, in IBMQFactory.load_account(self)\n    187     logger.warning('Credentials are already in use. The existing '\n    188                    'account in the session will be replaced.')\n    189     self.disable_account()\n--&gt; 191 self._initialize_providers(credentials, preferences)\n    193 # Prevent edge case where no hubs are available.\n    194 providers = self.providers()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:456, in IBMQFactory._initialize_providers(self, credentials, preferences)\n    446 def _initialize_providers(\n    447         self, credentials: Credentials,\n    448         preferences: Optional[Dict] = None\n    449 ) -&gt; None:\n    450 \"\"\"Authenticate against IBM Quantum and populate the providers.\n    451 \n    452     Args:\n    453         credentials: Credentials for IBM Quantum.\n    454         preferences: Account preferences.\n    455     \"\"\"\n--&gt; 456     auth_client = AuthClient(credentials.token,\n    457 credentials.base_url,\n    458 **credentials.connection_parameters())\n    459     service_urls = auth_client.current_service_urls()\n    460     user_hubs = auth_client.user_hubs()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:41, in AuthClient.__init__(self, api_token, auth_url, **request_kwargs)\n     38 self._service_urls = {}  # type: ignore[var-annotated]\n     40 self.auth_api = Api(RetrySession(auth_url, **request_kwargs))\n---&gt; 41 self.base_api = self._init_service_clients(**request_kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:53, in AuthClient._init_service_clients(self, **request_kwargs)\n     44 \"\"\"Initialize the clients used for communicating with the API.\n     45 \n     46 Args:\n   (...)\n     50     Client for the API server.\n     51 \"\"\"\n     52 # Request an access token.\n---&gt; 53 access_token = self._request_access_token()\n     54 # Use the token for the next auth server requests.\n     55 self.auth_api.session.access_token = access_token\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:75, in AuthClient._request_access_token(self)\n     65 \"\"\"Request a new access token from the API authentication service.\n     66 \n     67 Returns:\n   (...)\n     72     RequestsApiError: If the request failed.\n     73 \"\"\"\n     74 try:\n---&gt; 75     response = self.auth_api.login(self.api_token)\n     76     return response['id']\n     77 except RequestsApiError as ex:\n     78     # Get the original exception that raised.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/rest/root.py:125, in Api.login(self, api_token)\n    116 \"\"\"Login with token.\n    117 \n    118 Args:\n   (...)\n    122     JSON response.\n    123 \"\"\"\n    124 url = self.get_url('login')\n--&gt; 125 return self.session.post(url, json={'apiToken': api_token}).json()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/sessions.py:637, in Session.post(self, url, data, json, **kwargs)\n    626 def post(self, url, data=None, json=None, **kwargs):\n    627 r\"\"\"Sends a POST request. Returns :class:`Response` object.\n    628 \n    629     :param url: URL for the new :class:`Request` object.\n   (...)\n    634     :rtype: requests.Response\n    635     \"\"\"\n--&gt; 637     return self.request(\"POST\", url, data=data, json=json, **kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:300, in RetrySession.request(self, method, url, bare, **kwargs)\n    297         # Modify the original message on the chained exceptions.\n    298         self._modify_chained_exception_messages(ex)\n--&gt; 300     raise RequestsApiError(message, status_code) from ex\n    302 return response\n\nRequestsApiError: '401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Login failed., Error code: 3446.'</pre>"},{"location":"black_box/balanced_in_eq_out/#balanced-input-equal-output","title":"Balanced: Input equal Output.\u00b6","text":""},{"location":"black_box/balanced_in_neq_out/","title":"Balanced: Input not equal Output.","text":"<p>Create the quantum Circuit.</p> In\u00a0[1]: Copied! <pre>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n\nqrx = QuantumRegister(1, 'q0')\nqry = QuantumRegister(1, 'q1')\ncr = ClassicalRegister(1, 'c')\n\nqc = QuantumCircuit(qrx, qry, cr)\nqc.h(qrx)\nqc.x(qry)\nqc.h(qry)\nqc.barrier()\nqc.x(qry)\nqc.cx(qrx, qry)\nqc.barrier()\nqc.h(qrx)\nqc.h(qry)\nqc.measure(qrx, cr)\nqc.draw(\"mpl\")\n</pre> from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister  qrx = QuantumRegister(1, 'q0') qry = QuantumRegister(1, 'q1') cr = ClassicalRegister(1, 'c')  qc = QuantumCircuit(qrx, qry, cr) qc.h(qrx) qc.x(qry) qc.h(qry) qc.barrier() qc.x(qry) qc.cx(qrx, qry) qc.barrier() qc.h(qrx) qc.h(qry) qc.measure(qrx, cr) qc.draw(\"mpl\") Out[1]: <p>Proof through histogram.</p> In\u00a0[2]: Copied! <pre>from qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\n\nsim = AerSimulator()\njob = execute(qc, backend = sim, shots = 1000)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Counts: \", counts)\nplot_histogram(counts)\n</pre> from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram  sim = AerSimulator() job = execute(qc, backend = sim, shots = 1000) result = job.result() counts = result.get_counts(qc) print(\"Counts: \", counts) plot_histogram(counts) <pre>Counts:  {'1': 1000}\n</pre> Out[2]: <p>Also in Quantum Computer.</p> In\u00a0[3]: Copied! <pre>from qiskit import QuantumCircuit, IBMQ, execute \nfrom qiskit.tools.monitor import job_monitor\nfrom qiskit.visualization import plot_histogram\n\nIBMQ.save_account('your_token')\nIBMQ.load_account()\nIBMQ.providers()\nprovider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')\nqcomp = provider.get_backend('ibmq_manila')\njob = execute(qc, backend = qcomp, shots = 1000)\njob_monitor(job)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\", counts)\nplot_histogram(counts)\n</pre> from qiskit import QuantumCircuit, IBMQ, execute  from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram  IBMQ.save_account('your_token') IBMQ.load_account() IBMQ.providers() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') qcomp = provider.get_backend('ibmq_manila') job = execute(qc, backend = qcomp, shots = 1000) job_monitor(job) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\", counts) plot_histogram(counts) <pre>/tmp/ipykernel_1947/811856264.py:5: DeprecationWarning: The package qiskit.providers.ibmq is being deprecated. Please see https://ibm.biz/provider_migration_guide to get instructions on how to migrate to qiskit-ibm-provider (https://github.com/Qiskit/qiskit-ibm-provider) and qiskit-ibm-runtime (https://github.com/Qiskit/qiskit-ibm-runtime).\n  IBMQ.save_account('your_token')\n/tmp/ipykernel_1947/811856264.py:5: DeprecationWarning: The qiskit.IBMQ entrypoint and the qiskit-ibmq-provider package (accessible from 'qiskit.providers.ibmq`) are deprecated and will be removed in a future release. Instead you should use the qiskit-ibm-provider package which is accessible from 'qiskit_ibm_provider'. You can install it with 'pip install qiskit_ibm_provider'. Just replace 'qiskit.IBMQ' with 'qiskit_ibm_provider.IBMProvider'\n  IBMQ.save_account('your_token')\nconfigrc.store_credentials:WARNING:2023-06-16 13:12:04,150: Credentials already present. Set overwrite=True to overwrite.\n</pre> <pre>\n---------------------------------------------------------------------------\nHTTPError                                 Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:278, in RetrySession.request(self, method, url, bare, **kwargs)\n    277     response = super().request(method, final_url, headers=headers, **kwargs)\n--&gt; 278     response.raise_for_status()\n    279 except RequestException as ex:\n    280     # Wrap the requests exceptions into a IBM Q custom one, for\n    281     # compatibility.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/models.py:1021, in Response.raise_for_status(self)\n   1020 if http_error_msg:\n-&gt; 1021     raise HTTPError(http_error_msg, response=self)\n\nHTTPError: 401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken\n\nThe above exception was the direct cause of the following exception:\n\nRequestsApiError                          Traceback (most recent call last)\nCell In[3], line 6\n      3 from qiskit.visualization import plot_histogram\n      5 IBMQ.save_account('your_token')\n----&gt; 6 IBMQ.load_account()\n      7 IBMQ.providers()\n      8 provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:191, in IBMQFactory.load_account(self)\n    187     logger.warning('Credentials are already in use. The existing '\n    188                    'account in the session will be replaced.')\n    189     self.disable_account()\n--&gt; 191 self._initialize_providers(credentials, preferences)\n    193 # Prevent edge case where no hubs are available.\n    194 providers = self.providers()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:456, in IBMQFactory._initialize_providers(self, credentials, preferences)\n    446 def _initialize_providers(\n    447         self, credentials: Credentials,\n    448         preferences: Optional[Dict] = None\n    449 ) -&gt; None:\n    450 \"\"\"Authenticate against IBM Quantum and populate the providers.\n    451 \n    452     Args:\n    453         credentials: Credentials for IBM Quantum.\n    454         preferences: Account preferences.\n    455     \"\"\"\n--&gt; 456     auth_client = AuthClient(credentials.token,\n    457 credentials.base_url,\n    458 **credentials.connection_parameters())\n    459     service_urls = auth_client.current_service_urls()\n    460     user_hubs = auth_client.user_hubs()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:41, in AuthClient.__init__(self, api_token, auth_url, **request_kwargs)\n     38 self._service_urls = {}  # type: ignore[var-annotated]\n     40 self.auth_api = Api(RetrySession(auth_url, **request_kwargs))\n---&gt; 41 self.base_api = self._init_service_clients(**request_kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:53, in AuthClient._init_service_clients(self, **request_kwargs)\n     44 \"\"\"Initialize the clients used for communicating with the API.\n     45 \n     46 Args:\n   (...)\n     50     Client for the API server.\n     51 \"\"\"\n     52 # Request an access token.\n---&gt; 53 access_token = self._request_access_token()\n     54 # Use the token for the next auth server requests.\n     55 self.auth_api.session.access_token = access_token\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:75, in AuthClient._request_access_token(self)\n     65 \"\"\"Request a new access token from the API authentication service.\n     66 \n     67 Returns:\n   (...)\n     72     RequestsApiError: If the request failed.\n     73 \"\"\"\n     74 try:\n---&gt; 75     response = self.auth_api.login(self.api_token)\n     76     return response['id']\n     77 except RequestsApiError as ex:\n     78     # Get the original exception that raised.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/rest/root.py:125, in Api.login(self, api_token)\n    116 \"\"\"Login with token.\n    117 \n    118 Args:\n   (...)\n    122     JSON response.\n    123 \"\"\"\n    124 url = self.get_url('login')\n--&gt; 125 return self.session.post(url, json={'apiToken': api_token}).json()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/sessions.py:637, in Session.post(self, url, data, json, **kwargs)\n    626 def post(self, url, data=None, json=None, **kwargs):\n    627 r\"\"\"Sends a POST request. Returns :class:`Response` object.\n    628 \n    629     :param url: URL for the new :class:`Request` object.\n   (...)\n    634     :rtype: requests.Response\n    635     \"\"\"\n--&gt; 637     return self.request(\"POST\", url, data=data, json=json, **kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:300, in RetrySession.request(self, method, url, bare, **kwargs)\n    297         # Modify the original message on the chained exceptions.\n    298         self._modify_chained_exception_messages(ex)\n--&gt; 300     raise RequestsApiError(message, status_code) from ex\n    302 return response\n\nRequestsApiError: '401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Login failed., Error code: 3446.'</pre>"},{"location":"black_box/balanced_in_neq_out/#balanced-input-not-equal-output","title":"Balanced: Input not equal Output.\u00b6","text":""},{"location":"black_box/constant_eq_0/","title":"Constant: Output equal 0.","text":"<p>Create the quantum Circuit.</p> In\u00a0[1]: Copied! <pre>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n\nqrx = QuantumRegister(1, 'q0')\nqry = QuantumRegister(1, 'q1')\ncr = ClassicalRegister(1, 'c')\n\nqc = QuantumCircuit(qrx, qry, cr)\nqc.h(qrx)\nqc.x(qry)\nqc.h(qry)\nqc.barrier()\nqc.i(qry)\nqc.barrier()\nqc.h(qrx)\nqc.h(qry)\nqc.measure(qrx, cr)\nqc.draw(\"mpl\")\n</pre> from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister  qrx = QuantumRegister(1, 'q0') qry = QuantumRegister(1, 'q1') cr = ClassicalRegister(1, 'c')  qc = QuantumCircuit(qrx, qry, cr) qc.h(qrx) qc.x(qry) qc.h(qry) qc.barrier() qc.i(qry) qc.barrier() qc.h(qrx) qc.h(qry) qc.measure(qrx, cr) qc.draw(\"mpl\") Out[1]: <p>Proof through histogram.</p> In\u00a0[2]: Copied! <pre>from qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\n\nsim = AerSimulator()\njob = execute(qc, backend = sim, shots = 1000)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Counts: \", counts)\nplot_histogram(counts)\n</pre> from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram  sim = AerSimulator() job = execute(qc, backend = sim, shots = 1000) result = job.result() counts = result.get_counts(qc) print(\"Counts: \", counts) plot_histogram(counts) <pre>Counts:  {'0': 1000}\n</pre> Out[2]: <p>Also in Quantum Computer.</p> In\u00a0[3]: Copied! <pre>from qiskit import QuantumCircuit, IBMQ, execute \nfrom qiskit.tools.monitor import job_monitor\nfrom qiskit.visualization import plot_histogram\n\nIBMQ.save_account('your_token')\nIBMQ.load_account()\nIBMQ.providers()\nprovider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')\nqcomp = provider.get_backend('ibmq_manila')\njob = execute(qc, backend = qcomp, shots = 1000)\njob_monitor(job)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\", counts)\nplot_histogram(counts)\n</pre> from qiskit import QuantumCircuit, IBMQ, execute  from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram  IBMQ.save_account('your_token') IBMQ.load_account() IBMQ.providers() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') qcomp = provider.get_backend('ibmq_manila') job = execute(qc, backend = qcomp, shots = 1000) job_monitor(job) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\", counts) plot_histogram(counts) <pre>/tmp/ipykernel_1969/811856264.py:5: DeprecationWarning: The package qiskit.providers.ibmq is being deprecated. Please see https://ibm.biz/provider_migration_guide to get instructions on how to migrate to qiskit-ibm-provider (https://github.com/Qiskit/qiskit-ibm-provider) and qiskit-ibm-runtime (https://github.com/Qiskit/qiskit-ibm-runtime).\n  IBMQ.save_account('your_token')\n/tmp/ipykernel_1969/811856264.py:5: DeprecationWarning: The qiskit.IBMQ entrypoint and the qiskit-ibmq-provider package (accessible from 'qiskit.providers.ibmq`) are deprecated and will be removed in a future release. Instead you should use the qiskit-ibm-provider package which is accessible from 'qiskit_ibm_provider'. You can install it with 'pip install qiskit_ibm_provider'. Just replace 'qiskit.IBMQ' with 'qiskit_ibm_provider.IBMProvider'\n  IBMQ.save_account('your_token')\nconfigrc.store_credentials:WARNING:2023-06-16 13:12:10,148: Credentials already present. Set overwrite=True to overwrite.\n</pre> <pre>\n---------------------------------------------------------------------------\nHTTPError                                 Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:278, in RetrySession.request(self, method, url, bare, **kwargs)\n    277     response = super().request(method, final_url, headers=headers, **kwargs)\n--&gt; 278     response.raise_for_status()\n    279 except RequestException as ex:\n    280     # Wrap the requests exceptions into a IBM Q custom one, for\n    281     # compatibility.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/models.py:1021, in Response.raise_for_status(self)\n   1020 if http_error_msg:\n-&gt; 1021     raise HTTPError(http_error_msg, response=self)\n\nHTTPError: 401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken\n\nThe above exception was the direct cause of the following exception:\n\nRequestsApiError                          Traceback (most recent call last)\nCell In[3], line 6\n      3 from qiskit.visualization import plot_histogram\n      5 IBMQ.save_account('your_token')\n----&gt; 6 IBMQ.load_account()\n      7 IBMQ.providers()\n      8 provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:191, in IBMQFactory.load_account(self)\n    187     logger.warning('Credentials are already in use. The existing '\n    188                    'account in the session will be replaced.')\n    189     self.disable_account()\n--&gt; 191 self._initialize_providers(credentials, preferences)\n    193 # Prevent edge case where no hubs are available.\n    194 providers = self.providers()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:456, in IBMQFactory._initialize_providers(self, credentials, preferences)\n    446 def _initialize_providers(\n    447         self, credentials: Credentials,\n    448         preferences: Optional[Dict] = None\n    449 ) -&gt; None:\n    450 \"\"\"Authenticate against IBM Quantum and populate the providers.\n    451 \n    452     Args:\n    453         credentials: Credentials for IBM Quantum.\n    454         preferences: Account preferences.\n    455     \"\"\"\n--&gt; 456     auth_client = AuthClient(credentials.token,\n    457 credentials.base_url,\n    458 **credentials.connection_parameters())\n    459     service_urls = auth_client.current_service_urls()\n    460     user_hubs = auth_client.user_hubs()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:41, in AuthClient.__init__(self, api_token, auth_url, **request_kwargs)\n     38 self._service_urls = {}  # type: ignore[var-annotated]\n     40 self.auth_api = Api(RetrySession(auth_url, **request_kwargs))\n---&gt; 41 self.base_api = self._init_service_clients(**request_kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:53, in AuthClient._init_service_clients(self, **request_kwargs)\n     44 \"\"\"Initialize the clients used for communicating with the API.\n     45 \n     46 Args:\n   (...)\n     50     Client for the API server.\n     51 \"\"\"\n     52 # Request an access token.\n---&gt; 53 access_token = self._request_access_token()\n     54 # Use the token for the next auth server requests.\n     55 self.auth_api.session.access_token = access_token\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:75, in AuthClient._request_access_token(self)\n     65 \"\"\"Request a new access token from the API authentication service.\n     66 \n     67 Returns:\n   (...)\n     72     RequestsApiError: If the request failed.\n     73 \"\"\"\n     74 try:\n---&gt; 75     response = self.auth_api.login(self.api_token)\n     76     return response['id']\n     77 except RequestsApiError as ex:\n     78     # Get the original exception that raised.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/rest/root.py:125, in Api.login(self, api_token)\n    116 \"\"\"Login with token.\n    117 \n    118 Args:\n   (...)\n    122     JSON response.\n    123 \"\"\"\n    124 url = self.get_url('login')\n--&gt; 125 return self.session.post(url, json={'apiToken': api_token}).json()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/sessions.py:637, in Session.post(self, url, data, json, **kwargs)\n    626 def post(self, url, data=None, json=None, **kwargs):\n    627 r\"\"\"Sends a POST request. Returns :class:`Response` object.\n    628 \n    629     :param url: URL for the new :class:`Request` object.\n   (...)\n    634     :rtype: requests.Response\n    635     \"\"\"\n--&gt; 637     return self.request(\"POST\", url, data=data, json=json, **kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:300, in RetrySession.request(self, method, url, bare, **kwargs)\n    297         # Modify the original message on the chained exceptions.\n    298         self._modify_chained_exception_messages(ex)\n--&gt; 300     raise RequestsApiError(message, status_code) from ex\n    302 return response\n\nRequestsApiError: '401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Login failed., Error code: 3446.'</pre>"},{"location":"black_box/constant_eq_0/#constant-output-equal-0","title":"Constant: Output equal 0.\u00b6","text":""},{"location":"black_box/constant_eq_1/","title":"Constant: Output equal 1.","text":"<p>Create the quantum Circuit.</p> In\u00a0[1]: Copied! <pre>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n\nqrx = QuantumRegister(1, 'q0')\nqry = QuantumRegister(1, 'q1')\ncr = ClassicalRegister(1, 'c')\n\nqc = QuantumCircuit(qrx, qry, cr)\nqc.h(qrx)\nqc.x(qry)\nqc.h(qry)\nqc.barrier()\nqc.x(qry)\nqc.barrier()\nqc.h(qrx)\nqc.h(qry)\nqc.measure(qrx, cr)\nqc.draw(\"mpl\")\n</pre> from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister  qrx = QuantumRegister(1, 'q0') qry = QuantumRegister(1, 'q1') cr = ClassicalRegister(1, 'c')  qc = QuantumCircuit(qrx, qry, cr) qc.h(qrx) qc.x(qry) qc.h(qry) qc.barrier() qc.x(qry) qc.barrier() qc.h(qrx) qc.h(qry) qc.measure(qrx, cr) qc.draw(\"mpl\") Out[1]: <p>Proof through histogram.</p> In\u00a0[2]: Copied! <pre>from qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\n\nsim = AerSimulator()\njob = execute(qc, backend = sim, shots = 1000)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Counts: \", counts)\nplot_histogram(counts)\n</pre> from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram  sim = AerSimulator() job = execute(qc, backend = sim, shots = 1000) result = job.result() counts = result.get_counts(qc) print(\"Counts: \", counts) plot_histogram(counts) <pre>Counts:  {'0': 1000}\n</pre> Out[2]: <p>Also in Quantum Computer.</p> In\u00a0[3]: Copied! <pre>from qiskit import QuantumCircuit, IBMQ, execute \nfrom qiskit.tools.monitor import job_monitor\nfrom qiskit.visualization import plot_histogram\n\nIBMQ.save_account('your_token')\nIBMQ.load_account()\nIBMQ.providers()\nprovider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')\nqcomp = provider.get_backend('ibmq_manila')\njob = execute(qc, backend = qcomp, shots = 1000)\njob_monitor(job)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\", counts)\nplot_histogram(counts)\n</pre> from qiskit import QuantumCircuit, IBMQ, execute  from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram  IBMQ.save_account('your_token') IBMQ.load_account() IBMQ.providers() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') qcomp = provider.get_backend('ibmq_manila') job = execute(qc, backend = qcomp, shots = 1000) job_monitor(job) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\", counts) plot_histogram(counts) <pre>/tmp/ipykernel_1994/811856264.py:5: DeprecationWarning: The package qiskit.providers.ibmq is being deprecated. Please see https://ibm.biz/provider_migration_guide to get instructions on how to migrate to qiskit-ibm-provider (https://github.com/Qiskit/qiskit-ibm-provider) and qiskit-ibm-runtime (https://github.com/Qiskit/qiskit-ibm-runtime).\n  IBMQ.save_account('your_token')\n/tmp/ipykernel_1994/811856264.py:5: DeprecationWarning: The qiskit.IBMQ entrypoint and the qiskit-ibmq-provider package (accessible from 'qiskit.providers.ibmq`) are deprecated and will be removed in a future release. Instead you should use the qiskit-ibm-provider package which is accessible from 'qiskit_ibm_provider'. You can install it with 'pip install qiskit_ibm_provider'. Just replace 'qiskit.IBMQ' with 'qiskit_ibm_provider.IBMProvider'\n  IBMQ.save_account('your_token')\nconfigrc.store_credentials:WARNING:2023-06-16 13:12:16,404: Credentials already present. Set overwrite=True to overwrite.\n</pre> <pre>\n---------------------------------------------------------------------------\nHTTPError                                 Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:278, in RetrySession.request(self, method, url, bare, **kwargs)\n    277     response = super().request(method, final_url, headers=headers, **kwargs)\n--&gt; 278     response.raise_for_status()\n    279 except RequestException as ex:\n    280     # Wrap the requests exceptions into a IBM Q custom one, for\n    281     # compatibility.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/models.py:1021, in Response.raise_for_status(self)\n   1020 if http_error_msg:\n-&gt; 1021     raise HTTPError(http_error_msg, response=self)\n\nHTTPError: 401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken\n\nThe above exception was the direct cause of the following exception:\n\nRequestsApiError                          Traceback (most recent call last)\nCell In[3], line 6\n      3 from qiskit.visualization import plot_histogram\n      5 IBMQ.save_account('your_token')\n----&gt; 6 IBMQ.load_account()\n      7 IBMQ.providers()\n      8 provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:191, in IBMQFactory.load_account(self)\n    187     logger.warning('Credentials are already in use. The existing '\n    188                    'account in the session will be replaced.')\n    189     self.disable_account()\n--&gt; 191 self._initialize_providers(credentials, preferences)\n    193 # Prevent edge case where no hubs are available.\n    194 providers = self.providers()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:456, in IBMQFactory._initialize_providers(self, credentials, preferences)\n    446 def _initialize_providers(\n    447         self, credentials: Credentials,\n    448         preferences: Optional[Dict] = None\n    449 ) -&gt; None:\n    450 \"\"\"Authenticate against IBM Quantum and populate the providers.\n    451 \n    452     Args:\n    453         credentials: Credentials for IBM Quantum.\n    454         preferences: Account preferences.\n    455     \"\"\"\n--&gt; 456     auth_client = AuthClient(credentials.token,\n    457 credentials.base_url,\n    458 **credentials.connection_parameters())\n    459     service_urls = auth_client.current_service_urls()\n    460     user_hubs = auth_client.user_hubs()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:41, in AuthClient.__init__(self, api_token, auth_url, **request_kwargs)\n     38 self._service_urls = {}  # type: ignore[var-annotated]\n     40 self.auth_api = Api(RetrySession(auth_url, **request_kwargs))\n---&gt; 41 self.base_api = self._init_service_clients(**request_kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:53, in AuthClient._init_service_clients(self, **request_kwargs)\n     44 \"\"\"Initialize the clients used for communicating with the API.\n     45 \n     46 Args:\n   (...)\n     50     Client for the API server.\n     51 \"\"\"\n     52 # Request an access token.\n---&gt; 53 access_token = self._request_access_token()\n     54 # Use the token for the next auth server requests.\n     55 self.auth_api.session.access_token = access_token\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:75, in AuthClient._request_access_token(self)\n     65 \"\"\"Request a new access token from the API authentication service.\n     66 \n     67 Returns:\n   (...)\n     72     RequestsApiError: If the request failed.\n     73 \"\"\"\n     74 try:\n---&gt; 75     response = self.auth_api.login(self.api_token)\n     76     return response['id']\n     77 except RequestsApiError as ex:\n     78     # Get the original exception that raised.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/rest/root.py:125, in Api.login(self, api_token)\n    116 \"\"\"Login with token.\n    117 \n    118 Args:\n   (...)\n    122     JSON response.\n    123 \"\"\"\n    124 url = self.get_url('login')\n--&gt; 125 return self.session.post(url, json={'apiToken': api_token}).json()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/sessions.py:637, in Session.post(self, url, data, json, **kwargs)\n    626 def post(self, url, data=None, json=None, **kwargs):\n    627 r\"\"\"Sends a POST request. Returns :class:`Response` object.\n    628 \n    629     :param url: URL for the new :class:`Request` object.\n   (...)\n    634     :rtype: requests.Response\n    635     \"\"\"\n--&gt; 637     return self.request(\"POST\", url, data=data, json=json, **kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:300, in RetrySession.request(self, method, url, bare, **kwargs)\n    297         # Modify the original message on the chained exceptions.\n    298         self._modify_chained_exception_messages(ex)\n--&gt; 300     raise RequestsApiError(message, status_code) from ex\n    302 return response\n\nRequestsApiError: '401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Login failed., Error code: 3446.'</pre>"},{"location":"black_box/constant_eq_1/#constant-output-equal-1","title":"Constant: Output equal 1.\u00b6","text":""},{"location":"quantum_computing/Code-App1/","title":"\u9644\u93041\u539f\u59cb\u7a0b\u5f0f\u78bc","text":"In\u00a0[1]: Copied! <pre>#Below are examples of using print function\nprint('The name of the language is',\"Python\")\nprint(\"The radius of the circle is\", 3, '\\nIts area is', 3.14159*3**2)\n</pre> #Below are examples of using print function print('The name of the language is',\"Python\") print(\"The radius of the circle is\", 3, '\\nIts area is', 3.14159*3**2) <pre>The name of the language is Python\nThe radius of the circle is 3 \nIts area is 28.27431\n</pre> In\u00a0[2]: Copied! <pre>#Below are examples of using print function\nprint('The name of the language is',\"Python\",end=\". \")\nprint('Its version is',\"3.x\",sep=\"....\")\nprint(\"The radius of the circle is\", 3)\nprint(\"The area of the circle is\", 3.14159*3**2)\n</pre> #Below are examples of using print function print('The name of the language is',\"Python\",end=\". \") print('Its version is',\"3.x\",sep=\"....\") print(\"The radius of the circle is\", 3) print(\"The area of the circle is\", 3.14159*3**2) <pre>The name of the language is Python. Its version is....3.x\nThe radius of the circle is 3\nThe area of the circle is 28.27431\n</pre> In\u00a0[3]: Copied! <pre>r=input('Please enter the radius of the circle:')\nprint('The radius of the circle:', r)\n</pre> r=input('Please enter the radius of the circle:') print('The radius of the circle:', r)  <pre>\n---------------------------------------------------------------------------\nStdinNotImplementedError                  Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 r=input('Please enter the radius of the circle:')\n      2 print('The radius of the circle:', r) \n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/ipykernel/kernelbase.py:1190, in Kernel.raw_input(self, prompt)\n   1188 if not self._allow_stdin:\n   1189     msg = \"raw_input was called, but this frontend does not support input requests.\"\n-&gt; 1190     raise StdinNotImplementedError(msg)\n   1191 return self._input_request(\n   1192     str(prompt),\n   1193     self._parent_ident[\"shell\"],\n   1194     self.get_parent(\"shell\"),\n   1195     password=False,\n   1196 )\n\nStdinNotImplementedError: raw_input was called, but this frontend does not support input requests.</pre> In\u00a0[4]: Copied! <pre>r=input('Please enter the radius of the circle:')\nri=int(r)\nrf=float(r)\nprint('The radius of the circle:', ri) \nprint(\"The area of the circle:\", 3.14159*rf**2)\n</pre> r=input('Please enter the radius of the circle:') ri=int(r) rf=float(r) print('The radius of the circle:', ri)  print(\"The area of the circle:\", 3.14159*rf**2) <pre>\n---------------------------------------------------------------------------\nStdinNotImplementedError                  Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 r=input('Please enter the radius of the circle:')\n      2 ri=int(r)\n      3 rf=float(r)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/ipykernel/kernelbase.py:1190, in Kernel.raw_input(self, prompt)\n   1188 if not self._allow_stdin:\n   1189     msg = \"raw_input was called, but this frontend does not support input requests.\"\n-&gt; 1190     raise StdinNotImplementedError(msg)\n   1191 return self._input_request(\n   1192     str(prompt),\n   1193     self._parent_ident[\"shell\"],\n   1194     self.get_parent(\"shell\"),\n   1195     password=False,\n   1196 )\n\nStdinNotImplementedError: raw_input was called, but this frontend does not support input requests.</pre> In\u00a0[5]: Copied! <pre>a=123;b=123.456;c=False;d=123+456j;e=\"123\";f=[1,2,3];g=(1,2,3);h={1,2,3};i={1:'x',2:'y',3:'z'}\nprint(type(a),type(b),type(c),type(d),type(e),type(f),type(g),type(h),type(i))\n</pre> a=123;b=123.456;c=False;d=123+456j;e=\"123\";f=[1,2,3];g=(1,2,3);h={1,2,3};i={1:'x',2:'y',3:'z'} print(type(a),type(b),type(c),type(d),type(e),type(f),type(g),type(h),type(i)) <pre>&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt; &lt;class 'str'&gt; &lt;class 'list'&gt; &lt;class 'tuple'&gt; &lt;class 'set'&gt; &lt;class 'dict'&gt;\n</pre> In\u00a0[6]: Copied! <pre>a=3;b=8\nprint(a+b)  #11\nprint(a-b)  #-5\nprint(a*b)  #24\nprint(a/b)  #0.375\nprint(a//b) #0\nprint(a%b)  #3\nprint(a**b) #6561\nprint(a+b//a**b)    #3\nprint((a+b)//a**b)  #0\n</pre> a=3;b=8 print(a+b)  #11 print(a-b)  #-5 print(a*b)  #24 print(a/b)  #0.375 print(a//b) #0 print(a%b)  #3 print(a**b) #6561 print(a+b//a**b)    #3 print((a+b)//a**b)  #0  <pre>11\n-5\n24\n0.375\n0\n3\n6561\n3\n0\n</pre> In\u00a0[7]: Copied! <pre>a=3.0;b=8.0;c=8\nprint(a+b)  #11.0\nprint(a-b)  #-5.0\nprint(a*b)  #24.0\nprint(a/b)  #0.375\nprint(a//b) #0.0\nprint(a%b)  #3.0\nprint(a**b) #6561.0\nprint(a+c)  #11.0\nprint(a+b//a**b)    #3.0\nprint((a+b)//a**b)  #0.0\n</pre> a=3.0;b=8.0;c=8 print(a+b)  #11.0 print(a-b)  #-5.0 print(a*b)  #24.0 print(a/b)  #0.375 print(a//b) #0.0 print(a%b)  #3.0 print(a**b) #6561.0 print(a+c)  #11.0 print(a+b//a**b)    #3.0 print((a+b)//a**b)  #0.0 <pre>11.0\n-5.0\n24.0\n0.375\n0.0\n3.0\n6561.0\n11.0\n3.0\n0.0\n</pre> In\u00a0[8]: Copied! <pre>a=3.0;b=8.0;c=8\nprint(a==b)  #False\nprint(a!=b)  #True\nprint(a&gt;b)   #False\nprint(a&lt;b)   #True\nprint(a&gt;=b)  #False\nprint(a&lt;=b)  #True\nprint(not (a==b)) #True\nprint(a==b or a!=b and a&gt;b)       #False\nprint(a==b and a&gt;b or a!=b)       #True\nprint(a==b and a&gt;b or not (a!=b)) #False\n</pre> a=3.0;b=8.0;c=8 print(a==b)  #False print(a!=b)  #True print(a&gt;b)   #False print(a=b)  #False print(a&lt;=b)  #True print(not (a==b)) #True print(a==b or a!=b and a&gt;b)       #False print(a==b and a&gt;b or a!=b)       #True print(a==b and a&gt;b or not (a!=b)) #False <pre>False\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\nTrue\nFalse\n</pre> In\u00a0[9]: Copied! <pre>a=2+4j;b=3-8j\nprint(a+b)  #(5-4j)\nprint(a-b)  #(-1+12j)\nprint(a*b)  #(38-4j)\nprint(a/b)  #(-0.3561643835616438+0.3835616438356164j)\nprint(a+b/a)    #(0.7+2.6j)\nprint((a+b)/a)  #(-0.3-1.4j)\nprint(a.real)   #2.0\nprint(a.imag)   #4.0\nprint(a.conjugate()) #(2-4j)\nprint(abs(a))   #4.47213595499958\n</pre> a=2+4j;b=3-8j print(a+b)  #(5-4j) print(a-b)  #(-1+12j) print(a*b)  #(38-4j) print(a/b)  #(-0.3561643835616438+0.3835616438356164j) print(a+b/a)    #(0.7+2.6j) print((a+b)/a)  #(-0.3-1.4j) print(a.real)   #2.0 print(a.imag)   #4.0 print(a.conjugate()) #(2-4j) print(abs(a))   #4.47213595499958 <pre>(5-4j)\n(-1+12j)\n(38-4j)\n(-0.3561643835616438+0.3835616438356164j)\n(0.7+2.6j)\n(-0.3-1.4j)\n2.0\n4.0\n(2-4j)\n4.47213595499958\n</pre> In\u00a0[10]: Copied! <pre>a={1,2,3};b={2,4,6}\nprint(a|b)         #{1, 2, 3, 4, 6}\nprint(a.union(b))  #{1, 2, 3, 4, 6}\nprint(a&amp;b)               #{2}\nprint(a.intersection(b)) #{2}\nprint(a-b)               #{1,3}\nprint(a.difference(b))   #{1,3}\nprint(a^b)                        #{1,3,4,6}\nprint(a.symmetric_difference(b))  #{1,3,4,6}\n</pre> a={1,2,3};b={2,4,6} print(a|b)         #{1, 2, 3, 4, 6} print(a.union(b))  #{1, 2, 3, 4, 6} print(a&amp;b)               #{2} print(a.intersection(b)) #{2} print(a-b)               #{1,3} print(a.difference(b))   #{1,3} print(a^b)                        #{1,3,4,6} print(a.symmetric_difference(b))  #{1,3,4,6} <pre>{1, 2, 3, 4, 6}\n{1, 2, 3, 4, 6}\n{2}\n{2}\n{1, 3}\n{1, 3}\n{1, 3, 4, 6}\n{1, 3, 4, 6}\n</pre> In\u00a0[11]: Copied! <pre>ex = {\"a\":1, \"b\":2, \"c\":3, 1: \"integer\", 2.3: \"float\", 4+5j: \"complex\", (6,7): \"tuple\"}\nprint(ex[\"a\"],ex[\"b\"],ex[\"c\"],ex[1],ex[2.3],ex[4+5j],ex[(6,7)])\nex[\"a\"]=100\nprint(ex[\"a\"])\nprint(len(ex))\nex[\"d\"]=4\nprint(ex.get(\"d\"))\ndel ex[\"d\"]\nprint(ex.get(\"d\"))\nprint(\"e\" in ex)\nprint(\"e\" not in ex)\nprint(ex.keys())\nprint(ex.values())\n</pre> ex = {\"a\":1, \"b\":2, \"c\":3, 1: \"integer\", 2.3: \"float\", 4+5j: \"complex\", (6,7): \"tuple\"} print(ex[\"a\"],ex[\"b\"],ex[\"c\"],ex[1],ex[2.3],ex[4+5j],ex[(6,7)]) ex[\"a\"]=100 print(ex[\"a\"]) print(len(ex)) ex[\"d\"]=4 print(ex.get(\"d\")) del ex[\"d\"] print(ex.get(\"d\")) print(\"e\" in ex) print(\"e\" not in ex) print(ex.keys()) print(ex.values()) <pre>1 2 3 integer float complex tuple\n100\n7\n4\nNone\nFalse\nTrue\ndict_keys(['a', 'b', 'c', 1, 2.3, (4+5j), (6, 7)])\ndict_values([100, 2, 3, 'integer', 'float', 'complex', 'tuple'])\n</pre> In\u00a0[12]: Copied! <pre>a=5\na+=3  #a=a+3  (a=8)\na-=3  #a=a-3  (a=5)\na*=3  #a=a*3  (a=15)\na%=8  #a=a%8  (a=7)\na//=3 #a=a//3 (a=2)\na/=3  #a=a/3  (a=0.6666666666666666)\na**=3 #a=a**3 (a=0.2962962962962962)\nprint(a)\n</pre> a=5 a+=3  #a=a+3  (a=8) a-=3  #a=a-3  (a=5) a*=3  #a=a*3  (a=15) a%=8  #a=a%8  (a=7) a//=3 #a=a//3 (a=2) a/=3  #a=a/3  (a=0.6666666666666666) a**=3 #a=a**3 (a=0.2962962962962962) print(a) <pre>0.2962962962962962\n</pre> In\u00a0[13]: Copied! <pre>score=90\nif score &gt;=60:\n  print(\"PASS\")\n</pre> score=90 if score &gt;=60:   print(\"PASS\") <pre>PASS\n</pre> In\u00a0[14]: Copied! <pre>score=90\nif score &gt;=60:\n  print(\"PASS\")\nelse:\n  print(\"FAIL\")\n</pre> score=90 if score &gt;=60:   print(\"PASS\") else:   print(\"FAIL\") <pre>PASS\n</pre> In\u00a0[15]: Copied! <pre>score=90\nif score &gt;=90:\n  print(\"A\")\nelif score &gt;= 80:\n  print(\"B\")\nelif score &gt;= 70:\n  print(\"C\")\nelif score &gt;= 60:\n  print(\"D\")\nelse:\n  print(\"F\")\n</pre> score=90 if score &gt;=90:   print(\"A\") elif score &gt;= 80:   print(\"B\") elif score &gt;= 70:   print(\"C\") elif score &gt;= 60:   print(\"D\") else:   print(\"F\") <pre>A\n</pre> In\u00a0[16]: Copied! <pre>i=0\nwhile i&lt;5:\n  i+=1  \n  print(i,end=\"\")\n</pre> i=0 while i&lt;5:   i+=1     print(i,end=\"\")  <pre>12345</pre> In\u00a0[17]: Copied! <pre>i=0\nwhile i&lt;5:\n  i+=1  \n  print(i,end=\"\")\nelse:\n  print(\"#\")\n</pre> i=0 while i&lt;5:   i+=1     print(i,end=\"\") else:   print(\"#\") <pre>12345#\n</pre> In\u00a0[18]: Copied! <pre>for i in [1,2,3,4,5]:\n  print(i,end=\"\")\n</pre> for i in [1,2,3,4,5]:   print(i,end=\"\") <pre>12345</pre> In\u00a0[19]: Copied! <pre>for i in [1,2,3,4,5]:\n  print(i,end=\"\")\nelse:\n  print(\"#\")\n</pre> for i in [1,2,3,4,5]:   print(i,end=\"\") else:   print(\"#\") <pre>12345#\n</pre> In\u00a0[20]: Copied! <pre>print(list(range(5)))       #range(5)\u6703\u56de\u50b30\u30011\u30012\u30013\u30014\nprint(list(range(2,5)))     #range(2,5)\u6703\u56de\u50b32\u30013\u30014\nprint(list(range(0,5,2)))   #range(0,2,5)\u6703\u56de\u50b30\u30012\u30014\nprint(list(range(5,0,-1)))  #range(5,0,-1)\u6703\u56de\u50b35\u30014\u30013\u30012\u30011\nprint(list(range(5,0)))     #range(5,0)\u662f\u4e00\u500b\u7a7a\u5e8f\u5217\n</pre> print(list(range(5)))       #range(5)\u6703\u56de\u50b30\u30011\u30012\u30013\u30014 print(list(range(2,5)))     #range(2,5)\u6703\u56de\u50b32\u30013\u30014 print(list(range(0,5,2)))   #range(0,2,5)\u6703\u56de\u50b30\u30012\u30014 print(list(range(5,0,-1)))  #range(5,0,-1)\u6703\u56de\u50b35\u30014\u30013\u30012\u30011 print(list(range(5,0)))     #range(5,0)\u662f\u4e00\u500b\u7a7a\u5e8f\u5217 <pre>[0, 1, 2, 3, 4]\n[2, 3, 4]\n[0, 2, 4]\n[5, 4, 3, 2, 1]\n[]\n</pre> In\u00a0[21]: Copied! <pre>i=0\nwhile i&lt;5:\n  i+=1  \n  if i==3:\n    break\n  print(i,end=\"\")\n</pre> i=0 while i&lt;5:   i+=1     if i==3:     break   print(i,end=\"\") <pre>12</pre> In\u00a0[22]: Copied! <pre>for i in range(1,6):\n  if i==3:\n    break\n  print(i,end=\"\")\n</pre> for i in range(1,6):   if i==3:     break   print(i,end=\"\") <pre>12</pre> In\u00a0[23]: Copied! <pre>i=0\nwhile i&lt;5:\n  i+=1  \n  if i==3:\n    continue\n  print(i,end=\"\")\n</pre> i=0 while i&lt;5:   i+=1     if i==3:     continue   print(i,end=\"\") <pre>1245</pre> In\u00a0[24]: Copied! <pre>for i in range(1,6):\n  if i==3:\n    continue\n  print(i,end=\"\")\n</pre> for i in range(1,6):   if i==3:     continue   print(i,end=\"\") <pre>1245</pre> In\u00a0[25]: Copied! <pre>def odd_check(n):\n\"\"\"Check if n is odd (return True) or not (return False).\"\"\"\n  if n%2==0:\n    return False\n  else:\n    return True\nprint(odd_check(5))\nprint(odd_check(10))\n</pre> def odd_check(n):   \"\"\"Check if n is odd (return True) or not (return False).\"\"\"   if n%2==0:     return False   else:     return True print(odd_check(5)) print(odd_check(10)) <pre>True\nFalse\n</pre> In\u00a0[26]: Copied! <pre>def test(aa,bb,cc=123,dd='abc'):\n  return aa,bb,cc,dd\nprint(test(1,2,3,4))\nprint(test(1,2,3))\nprint(test(1,2,dd='edf'))\nprint(test(1,2))\n</pre> def test(aa,bb,cc=123,dd='abc'):   return aa,bb,cc,dd print(test(1,2,3,4)) print(test(1,2,3)) print(test(1,2,dd='edf')) print(test(1,2)) <pre>(1, 2, 3, 4)\n(1, 2, 3, 'abc')\n(1, 2, 123, 'edf')\n(1, 2, 123, 'abc')\n</pre> In\u00a0[27]: Copied! <pre>def adding(*num):\n  sum=0\n  for n in num:\n    sum+=n\n  return sum\nprint(adding(1,2,3,4,5))\n</pre> def adding(*num):   sum=0   for n in num:     sum+=n   return sum print(adding(1,2,3,4,5)) <pre>15\n</pre> In\u00a0[28]: Copied! <pre>adding = lambda x,y: x+y \nprint(adding(3,8))             #\u986f\u793a11\nprint((lambda x,y: x+y)(3,8))  #\u986f\u793a11\nlista=[1,3,5,7,9]\n#\u4ee5\u4e0b\u5c07lambda\u51fd\u6578\u7576\u4f5cmap\u51fd\u6578\u7684\u53c3\u6578\nlistb=list(map(lambda x:x+8, lista)) \nprint(listb)\n</pre> adding = lambda x,y: x+y  print(adding(3,8))             #\u986f\u793a11 print((lambda x,y: x+y)(3,8))  #\u986f\u793a11 lista=[1,3,5,7,9] #\u4ee5\u4e0b\u5c07lambda\u51fd\u6578\u7576\u4f5cmap\u51fd\u6578\u7684\u53c3\u6578 listb=list(map(lambda x:x+8, lista))  print(listb) <pre>11\n11\n[9, 11, 13, 15, 17]\n</pre> In\u00a0[29]: Copied! <pre>class Rectangle:\n  length=0\n  width=0\n  def __init__(self,length,width):\n    self.length=length\n    self.width=width\n  def area(self):\n    return self.length*self.width\n  def perimeter(self):\n    return 2*(self.length+self.width)\nrect1=Rectangle(3,8)\nrect2=Rectangle(2,4)\nprint('rect1:',rect1.length,rect1.width,rect1.area(),rect1.perimeter())\nprint('rect2:',rect2.length,rect2.width,rect2.area(),rect2.perimeter())\n</pre> class Rectangle:   length=0   width=0   def __init__(self,length,width):     self.length=length     self.width=width   def area(self):     return self.length*self.width   def perimeter(self):     return 2*(self.length+self.width) rect1=Rectangle(3,8) rect2=Rectangle(2,4) print('rect1:',rect1.length,rect1.width,rect1.area(),rect1.perimeter()) print('rect2:',rect2.length,rect2.width,rect2.area(),rect2.perimeter()) <pre>rect1: 3 8 24 22\nrect2: 2 4 8 12\n</pre> In\u00a0[30]: Copied! <pre>class NamedRectangle(Rectangle):\n  name=''\n  def __init__(self,length,width,name):\n    super().__init__(length,width)\n    self.name=name\n  def show_name(self):\n    print(self.name)\nrect1=NamedRectangle(3,8,'rectangle1')\nrect2=NamedRectangle(2,4,'rectangle2')\nprint('rect1:',rect1.length,rect1.width,rect1.area(),rect1.perimeter())\nprint('rect2:',rect2.length,rect2.width,rect2.area(),rect2.perimeter())\nrect1.show_name()\nrect2.show_name()\n</pre> class NamedRectangle(Rectangle):   name=''   def __init__(self,length,width,name):     super().__init__(length,width)     self.name=name   def show_name(self):     print(self.name) rect1=NamedRectangle(3,8,'rectangle1') rect2=NamedRectangle(2,4,'rectangle2') print('rect1:',rect1.length,rect1.width,rect1.area(),rect1.perimeter()) print('rect2:',rect2.length,rect2.width,rect2.area(),rect2.perimeter()) rect1.show_name() rect2.show_name() <pre>rect1: 3 8 24 22\nrect2: 2 4 8 12\nrectangle1\nrectangle2\n</pre>"},{"location":"quantum_computing/Code-App1/#1","title":"\u9644\u93041\u539f\u59cb\u7a0b\u5f0f\u78bc\u00b6","text":""},{"location":"quantum_computing/Code-Ch1/","title":"\u7b2c1\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc","text":"In\u00a0[1]: Copied! <pre>#Program 1.1 The first quantum program\nfrom qiskit import QuantumCircuit\nprint(\"Hello, Qubit!\")\nqc = QuantumCircuit(1,1)\nqc.measure([0], [0])\nprint(\"This is a quantum circuit of 1 qubit and 1 bit:\")\nqc.draw('mpl')\n</pre> #Program 1.1 The first quantum program from qiskit import QuantumCircuit print(\"Hello, Qubit!\") qc = QuantumCircuit(1,1) qc.measure([0], [0]) print(\"This is a quantum circuit of 1 qubit and 1 bit:\") qc.draw('mpl') <pre>Hello, Qubit!\nThis is a quantum circuit of 1 qubit and 1 bit:\n</pre> Out[1]: In\u00a0[2]: Copied! <pre>#Program 1.2 Design a quantum circuit with 5 qubits and 3 classical bits\nfrom qiskit import QuantumCircuit\nprint(\"This is a quantum circuit of 5 qubits and 2 bits:\")\nqc = QuantumCircuit(5, 2)\nqc.measure([1,3], [0,1])\nqc.draw('mpl')\n</pre> #Program 1.2 Design a quantum circuit with 5 qubits and 3 classical bits from qiskit import QuantumCircuit print(\"This is a quantum circuit of 5 qubits and 2 bits:\") qc = QuantumCircuit(5, 2) qc.measure([1,3], [0,1]) qc.draw('mpl') <pre>This is a quantum circuit of 5 qubits and 2 bits:\n</pre> Out[2]: In\u00a0[3]: Copied! <pre>#Program 1.3 Name and label quantum bits and classical bits\nfrom qiskit import QuantumRegister,ClassicalRegister,QuantumCircuit\nqrx = QuantumRegister(3,'x')\nqry = QuantumRegister(2,'y')\nqrz = QuantumRegister(1,'z')\ncr = ClassicalRegister(4,'c')\nqc = QuantumCircuit(qrx,qry,qrz,cr)\nqc.measure([qrx[1],qrx[2]], [cr[0],cr[1]]) \nqc.measure([4,5], [2,3])\nqc.draw('mpl')\n</pre> #Program 1.3 Name and label quantum bits and classical bits from qiskit import QuantumRegister,ClassicalRegister,QuantumCircuit qrx = QuantumRegister(3,'x') qry = QuantumRegister(2,'y') qrz = QuantumRegister(1,'z') cr = ClassicalRegister(4,'c') qc = QuantumCircuit(qrx,qry,qrz,cr) qc.measure([qrx[1],qrx[2]], [cr[0],cr[1]])  qc.measure([4,5], [2,3]) qc.draw('mpl') Out[3]: In\u00a0[4]: Copied! <pre>#Program 1.4 Transpile and execute quantum circuit on simulator\nfrom qiskit import QuantumCircuit, transpile, execute\nfrom qiskit.providers.aer import AerSimulator\nsim = AerSimulator()\nqc = QuantumCircuit(1, 1)\nqc.measure([0], [0])\nprint(qc)\ncqc = transpile(qc, sim)\njob=execute(cqc, backend=sim, shots=1000)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\",counts)\n</pre> #Program 1.4 Transpile and execute quantum circuit on simulator from qiskit import QuantumCircuit, transpile, execute from qiskit.providers.aer import AerSimulator sim = AerSimulator() qc = QuantumCircuit(1, 1) qc.measure([0], [0]) print(qc) cqc = transpile(qc, sim) job=execute(cqc, backend=sim, shots=1000) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\",counts) <pre>     \u250c\u2500\u2510\n  q: \u2524M\u251c\n     \u2514\u2565\u2518\nc: 1/\u2550\u2569\u2550\n      0 \nTotal counts for qubit states are: {'0': 1000}\n</pre> In\u00a0[5]: Copied! <pre>#Program 1.5 Execute quantum circuit (program) on simulator\nfrom qiskit import QuantumCircuit, execute\nfrom qiskit.providers.aer import AerSimulator\nsim = AerSimulator()\nqc = QuantumCircuit(1, 1)\nqc.measure([0], [0])\nprint(qc)\njob=execute(qc, backend=sim, shots=1000)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\",counts)\n</pre> #Program 1.5 Execute quantum circuit (program) on simulator from qiskit import QuantumCircuit, execute from qiskit.providers.aer import AerSimulator sim = AerSimulator() qc = QuantumCircuit(1, 1) qc.measure([0], [0]) print(qc) job=execute(qc, backend=sim, shots=1000) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\",counts) <pre>     \u250c\u2500\u2510\n  q: \u2524M\u251c\n     \u2514\u2565\u2518\nc: 1/\u2550\u2569\u2550\n      0 \nTotal counts for qubit states are: {'0': 1000}\n</pre> <p>\u4ee5\u4e0b\u56e0\u70ba\u9700\u8981\u9023\u7dda\u5230\u9060\u7aef IBM-Q \u6240\u4ee5\u6703\u7121\u6cd5\u57f7\u884c\uff01</p> In\u00a0[6]: Copied! <pre>#Program 1.6 Execute quantum circuit (program) on least busy quantum computer\nfrom qiskit import QuantumCircuit, IBMQ, execute\nfrom qiskit.providers.ibmq import least_busy \nfrom qiskit.tools.monitor import job_monitor \nqc = QuantumCircuit(1, 1)\nqc.measure([0], [0])\nprint(qc)\nIBMQ.save_account('your_token',overwrite=True)\nIBMQ.load_account()\nprovider=IBMQ.get_provider(group='open')\nprint(provider)\nqcomp = least_busy(provider.backends(simulator=False))\nprint(\"The least busy quantum computer is:\",qcomp)\njob=execute(qc, backend=qcomp, shots=1000)\njob_monitor(job)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\",counts)\n</pre> #Program 1.6 Execute quantum circuit (program) on least busy quantum computer from qiskit import QuantumCircuit, IBMQ, execute from qiskit.providers.ibmq import least_busy  from qiskit.tools.monitor import job_monitor  qc = QuantumCircuit(1, 1) qc.measure([0], [0]) print(qc) IBMQ.save_account('your_token',overwrite=True) IBMQ.load_account() provider=IBMQ.get_provider(group='open') print(provider) qcomp = least_busy(provider.backends(simulator=False)) print(\"The least busy quantum computer is:\",qcomp) job=execute(qc, backend=qcomp, shots=1000) job_monitor(job) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\",counts) <pre>     \u250c\u2500\u2510\n  q: \u2524M\u251c\n     \u2514\u2565\u2518\nc: 1/\u2550\u2569\u2550\n      0 \n</pre> <pre>/tmp/ipykernel_2038/1065334184.py:8: DeprecationWarning: The qiskit.IBMQ entrypoint and the qiskit-ibmq-provider package (accessible from 'qiskit.providers.ibmq`) are deprecated and will be removed in a future release. Instead you should use the qiskit-ibm-provider package which is accessible from 'qiskit_ibm_provider'. You can install it with 'pip install qiskit_ibm_provider'. Just replace 'qiskit.IBMQ' with 'qiskit_ibm_provider.IBMProvider'\n  IBMQ.save_account('your_token',overwrite=True)\n</pre> <pre>\n---------------------------------------------------------------------------\nHTTPError                                 Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:278, in RetrySession.request(self, method, url, bare, **kwargs)\n    277     response = super().request(method, final_url, headers=headers, **kwargs)\n--&gt; 278     response.raise_for_status()\n    279 except RequestException as ex:\n    280     # Wrap the requests exceptions into a IBM Q custom one, for\n    281     # compatibility.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/models.py:1021, in Response.raise_for_status(self)\n   1020 if http_error_msg:\n-&gt; 1021     raise HTTPError(http_error_msg, response=self)\n\nHTTPError: 401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken\n\nThe above exception was the direct cause of the following exception:\n\nRequestsApiError                          Traceback (most recent call last)\nCell In[6], line 9\n      7 print(qc)\n      8 IBMQ.save_account('your_token',overwrite=True)\n----&gt; 9 IBMQ.load_account()\n     10 provider=IBMQ.get_provider(group='open')\n     11 print(provider)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:191, in IBMQFactory.load_account(self)\n    187     logger.warning('Credentials are already in use. The existing '\n    188                    'account in the session will be replaced.')\n    189     self.disable_account()\n--&gt; 191 self._initialize_providers(credentials, preferences)\n    193 # Prevent edge case where no hubs are available.\n    194 providers = self.providers()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:456, in IBMQFactory._initialize_providers(self, credentials, preferences)\n    446 def _initialize_providers(\n    447         self, credentials: Credentials,\n    448         preferences: Optional[Dict] = None\n    449 ) -&gt; None:\n    450 \"\"\"Authenticate against IBM Quantum and populate the providers.\n    451 \n    452     Args:\n    453         credentials: Credentials for IBM Quantum.\n    454         preferences: Account preferences.\n    455     \"\"\"\n--&gt; 456     auth_client = AuthClient(credentials.token,\n    457 credentials.base_url,\n    458 **credentials.connection_parameters())\n    459     service_urls = auth_client.current_service_urls()\n    460     user_hubs = auth_client.user_hubs()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:41, in AuthClient.__init__(self, api_token, auth_url, **request_kwargs)\n     38 self._service_urls = {}  # type: ignore[var-annotated]\n     40 self.auth_api = Api(RetrySession(auth_url, **request_kwargs))\n---&gt; 41 self.base_api = self._init_service_clients(**request_kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:53, in AuthClient._init_service_clients(self, **request_kwargs)\n     44 \"\"\"Initialize the clients used for communicating with the API.\n     45 \n     46 Args:\n   (...)\n     50     Client for the API server.\n     51 \"\"\"\n     52 # Request an access token.\n---&gt; 53 access_token = self._request_access_token()\n     54 # Use the token for the next auth server requests.\n     55 self.auth_api.session.access_token = access_token\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/clients/auth.py:75, in AuthClient._request_access_token(self)\n     65 \"\"\"Request a new access token from the API authentication service.\n     66 \n     67 Returns:\n   (...)\n     72     RequestsApiError: If the request failed.\n     73 \"\"\"\n     74 try:\n---&gt; 75     response = self.auth_api.login(self.api_token)\n     76     return response['id']\n     77 except RequestsApiError as ex:\n     78     # Get the original exception that raised.\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/rest/root.py:125, in Api.login(self, api_token)\n    116 \"\"\"Login with token.\n    117 \n    118 Args:\n   (...)\n    122     JSON response.\n    123 \"\"\"\n    124 url = self.get_url('login')\n--&gt; 125 return self.session.post(url, json={'apiToken': api_token}).json()\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/requests/sessions.py:637, in Session.post(self, url, data, json, **kwargs)\n    626 def post(self, url, data=None, json=None, **kwargs):\n    627 r\"\"\"Sends a POST request. Returns :class:`Response` object.\n    628 \n    629     :param url: URL for the new :class:`Request` object.\n   (...)\n    634     :rtype: requests.Response\n    635     \"\"\"\n--&gt; 637     return self.request(\"POST\", url, data=data, json=json, **kwargs)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/api/session.py:300, in RetrySession.request(self, method, url, bare, **kwargs)\n    297         # Modify the original message on the chained exceptions.\n    298         self._modify_chained_exception_messages(ex)\n--&gt; 300     raise RequestsApiError(message, status_code) from ex\n    302 return response\n\nRequestsApiError: '401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Login failed., Error code: 3446.'</pre> In\u00a0[7]: Copied! <pre>#Program 1.7 Execute quantum circuit (program) on proper quantum computer\nfrom qiskit import QuantumCircuit, IBMQ, execute\nfrom qiskit.tools.monitor import job_monitor \nqc = QuantumCircuit(1, 1)\nqc.measure([0], [0])\nprint(qc)\n#IBMQ.save_account('......',overwrite=True)\n#IBMQ.load_account()\nprovider = IBMQ.get_provider(group='open')\nqcomp = provider.get_backend('ibmq_lima')\njob=execute(qc, backend=qcomp, shots=1000)\njob_monitor(job)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\",counts)\n</pre> #Program 1.7 Execute quantum circuit (program) on proper quantum computer from qiskit import QuantumCircuit, IBMQ, execute from qiskit.tools.monitor import job_monitor  qc = QuantumCircuit(1, 1) qc.measure([0], [0]) print(qc) #IBMQ.save_account('......',overwrite=True) #IBMQ.load_account() provider = IBMQ.get_provider(group='open') qcomp = provider.get_backend('ibmq_lima') job=execute(qc, backend=qcomp, shots=1000) job_monitor(job) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\",counts) <pre>     \u250c\u2500\u2510\n  q: \u2524M\u251c\n     \u2514\u2565\u2518\nc: 1/\u2550\u2569\u2550\n      0 \n</pre> <pre>\n---------------------------------------------------------------------------\nIBMQProviderError                         Traceback (most recent call last)\nCell In[7], line 9\n      6 print(qc)\n      7 #IBMQ.save_account('......',overwrite=True)\n      8 #IBMQ.load_account()\n----&gt; 9 provider = IBMQ.get_provider(group='open')\n     10 qcomp = provider.get_backend('ibmq_lima')\n     11 job=execute(qc, backend=qcomp, shots=1000)\n\nFile /opt/hostedtoolcache/Python/3.9.17/x64/lib/python3.9/site-packages/qiskit/providers/ibmq/ibmqfactory.py:423, in IBMQFactory.get_provider(self, hub, group, project)\n    420 providers = self.providers(hub, group, project)\n    422 if not providers:\n--&gt; 423     raise IBMQProviderError('No provider matches the specified criteria: '\n    424                             'hub = {}, group = {}, project = {}'\n    425                             .format(hub, group, project))\n    426 if len(providers) &gt; 1:\n    427     raise IBMQProviderError('More than one provider matches the specified criteria.'\n    428                             'hub = {}, group = {}, project = {}'\n    429                             .format(hub, group, project))\n\nIBMQProviderError: 'No provider matches the specified criteria: hub = None, group = open, project = None'</pre>"},{"location":"quantum_computing/Code-Ch1/#1","title":"\u7b2c1\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc\u00b6","text":""},{"location":"quantum_computing/Code-Ch2/","title":"\u7b2c2\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc","text":"In\u00a0[1]: Copied! <pre>#Program 2.1 Initialize qubit state\nfrom qiskit import QuantumCircuit\nimport math\nqc = QuantumCircuit(4)\nqc.initialize([1,0],0)\nqc.initialize([0,1],1)\nqc.initialize([1/math.sqrt(2), 1/math.sqrt(2)],2)\nqc.initialize([1/math.sqrt(2), -1/math.sqrt(2)],3)\nqc.draw('mpl')\n</pre> #Program 2.1 Initialize qubit state from qiskit import QuantumCircuit import math qc = QuantumCircuit(4) qc.initialize([1,0],0) qc.initialize([0,1],1) qc.initialize([1/math.sqrt(2), 1/math.sqrt(2)],2) qc.initialize([1/math.sqrt(2), -1/math.sqrt(2)],3) qc.draw('mpl') Out[1]: In\u00a0[2]: Copied! <pre>#Program 2.2 Initialize qubit state and show Bloch sphere\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info import Statevector\nimport math\nqc = QuantumCircuit(4)\nqc.initialize([1,0],0)\nqc.initialize([0,1],1)\nqc.initialize([1/math.sqrt(2), 1/math.sqrt(2)],2)\nqc.initialize([1/math.sqrt(2), -1/math.sqrt(2)],3)\nstate = Statevector.from_instruction(qc)\ndisplay(qc.draw('mpl'))\ndisplay(state.draw('bloch'))\n</pre> #Program 2.2 Initialize qubit state and show Bloch sphere from qiskit import QuantumCircuit from qiskit.quantum_info import Statevector import math qc = QuantumCircuit(4) qc.initialize([1,0],0) qc.initialize([0,1],1) qc.initialize([1/math.sqrt(2), 1/math.sqrt(2)],2) qc.initialize([1/math.sqrt(2), -1/math.sqrt(2)],3) state = Statevector.from_instruction(qc) display(qc.draw('mpl')) display(state.draw('bloch')) In\u00a0[3]: Copied! <pre>#Program 2.3 Show Bloch sphere\nfrom qiskit.quantum_info import Statevector\nfrom qiskit.visualization import plot_bloch_multivector\nstate = Statevector.from_instruction(qc)\nplot_bloch_multivector(state)\n</pre> #Program 2.3 Show Bloch sphere from qiskit.quantum_info import Statevector from qiskit.visualization import plot_bloch_multivector state = Statevector.from_instruction(qc) plot_bloch_multivector(state) Out[3]: In\u00a0[4]: Copied! <pre>#Program 2.4 Measure qubit state\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nqc = QuantumCircuit(4,4)\nqc.initialize([1,0],0)\nqc.initialize([1,0],1)\nqc.initialize([0,1],2)\nqc.initialize([0,1],3)\nqc.measure([0,1,2,3],[0,1,2,3])\nprint(qc)\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 2.4 Measure qubit state from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram qc = QuantumCircuit(4,4) qc.initialize([1,0],0) qc.initialize([1,0],1) qc.initialize([0,1],2) qc.initialize([0,1],3) qc.measure([0,1,2,3],[0,1,2,3]) print(qc) sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510         \nq_0: \u2524 Initialize(1,0) \u251c\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510      \nq_1: \u2524 Initialize(1,0) \u251c\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510   \nq_2: \u2524 Initialize(0,1) \u251c\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551  \u2551 \u2514\u2565\u2518\u250c\u2500\u2510\nq_3: \u2524 Initialize(0,1) \u251c\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551  \u2551  \u2551 \u2514\u2565\u2518\nc: 4/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n                         0  1  2  3 \nCounts: {'1100': 1000}\n</pre> Out[4]: In\u00a0[5]: Copied! <pre>#Program 2.5 Measure qubit state again\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport math\nqc = QuantumCircuit(4,4)\nqc.initialize([1/math.sqrt(2), 1/math.sqrt(2)],0)\nqc.initialize([1/math.sqrt(2), -1/math.sqrt(2)],1)\nqc.initialize([1/math.sqrt(2), 1j/math.sqrt(2)],2)\nqc.initialize([1/math.sqrt(2), -1j/math.sqrt(2)],3)\nqc.measure([0,1,2,3],[0,1,2,3])\nprint(qc)\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 2.5 Measure qubit state again from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram import math qc = QuantumCircuit(4,4) qc.initialize([1/math.sqrt(2), 1/math.sqrt(2)],0) qc.initialize([1/math.sqrt(2), -1/math.sqrt(2)],1) qc.initialize([1/math.sqrt(2), 1j/math.sqrt(2)],2) qc.initialize([1/math.sqrt(2), -1j/math.sqrt(2)],3) qc.measure([0,1,2,3],[0,1,2,3]) print(qc) sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2510         \nq_0: \u2500\u2524 Initialize(0.70711,0.70711) \u251c\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2510\u2514\u2565\u2518\u250c\u2500\u2510      \nq_1: \u2500\u2524 Initialize(0.70711,-0.70711) \u251c\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\n      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510   \nq_2: \u2500\u2524 Initialize(0.70711,0.70711j) \u251c\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\n     \u250c\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2551  \u2551 \u2514\u2565\u2518\u250c\u2500\u2510\nq_3: \u2524 Initialize(0.70711,-0.70711j) \u251c\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551  \u2551  \u2551 \u2514\u2565\u2518\nc: 4/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n                                       0  1  2  3 \nCounts: {'1110': 60, '1010': 61, '0001': 62, '0011': 72, '0111': 66, '1011': 72, '0100': 67, '1100': 56, '0000': 63, '0010': 54, '1000': 57, '0110': 59, '1101': 68, '1111': 62, '1001': 64, '0101': 57}\n</pre> Out[5]:"},{"location":"quantum_computing/Code-Ch2/#2","title":"\u7b2c2\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc\u00b6","text":""},{"location":"quantum_computing/Code-Ch3/","title":"\u7b2c3\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc","text":"In\u00a0[1]: Copied! <pre>#Program 3.1a Apply X-gate to qubit\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(2)\nqc.x(1)\nqc.draw('mpl')\n</pre> #Program 3.1a Apply X-gate to qubit from qiskit import QuantumCircuit qc = QuantumCircuit(2) qc.x(1) qc.draw('mpl') Out[1]: In\u00a0[2]: Copied! <pre>#Program 3.1b Show Bloch sphere of qubit w/wo X-gate\nfrom qiskit.quantum_info import Statevector\nstate = Statevector.from_instruction(qc)\nstate.draw('bloch')\n</pre> #Program 3.1b Show Bloch sphere of qubit w/wo X-gate from qiskit.quantum_info import Statevector state = Statevector.from_instruction(qc) state.draw('bloch') Out[2]: In\u00a0[3]: Copied! <pre>#Program 3.2a Measure state of qubit w/o X-gate\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport math\nqc = QuantumCircuit(1,1)\nqc.initialize([math.sqrt(1/3), math.sqrt(2/3)],0)\nqc.measure([0],[0])\nprint(qc)\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 3.2a Measure state of qubit w/o X-gate from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram import math qc = QuantumCircuit(1,1) qc.initialize([math.sqrt(1/3), math.sqrt(2/3)],0) qc.measure([0],[0]) print(qc) sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n  q: \u2524 Initialize(0.57735,0.8165) \u251c\u2524M\u251c\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2565\u2518\nc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\n                                    0 \nCounts: {'1': 645, '0': 355}\n</pre> Out[3]: In\u00a0[4]: Copied! <pre>#Program 3.2b Measure state of qubit w/ X-gate\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport math\nqc = QuantumCircuit(1,1)\nqc.initialize([math.sqrt(1/3), math.sqrt(2/3)],0)\nqc.x(0)\nqc.measure([0],[0])\nprint(qc)\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 3.2b Measure state of qubit w/ X-gate from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram import math qc = QuantumCircuit(1,1) qc.initialize([math.sqrt(1/3), math.sqrt(2/3)],0) qc.x(0) qc.measure([0],[0]) print(qc) sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n  q: \u2524 Initialize(0.57735,0.8165) \u251c\u2524 X \u251c\u2524M\u251c\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\nc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\n                                         0 \nCounts: {'1': 342, '0': 658}\n</pre> Out[4]: In\u00a0[5]: Copied! <pre>#Program 3.3a Apply X-gate and H-gate to qubit\nfrom qiskit import QuantumCircuit\nimport math\nqc = QuantumCircuit(4)\nqc.initialize([1/math.sqrt(2), 1/math.sqrt(2)],0)\nqc.initialize([1/math.sqrt(2), -1/math.sqrt(2)],1)\nqc.h(2)\nqc.x(3)\nqc.h(3)\nqc.draw('mpl')\n</pre> #Program 3.3a Apply X-gate and H-gate to qubit from qiskit import QuantumCircuit import math qc = QuantumCircuit(4) qc.initialize([1/math.sqrt(2), 1/math.sqrt(2)],0) qc.initialize([1/math.sqrt(2), -1/math.sqrt(2)],1) qc.h(2) qc.x(3) qc.h(3) qc.draw('mpl') Out[5]: In\u00a0[6]: Copied! <pre>#Program 3.3b Show Bloch sphere of qubit w/ X-gate and H-gate\nfrom qiskit.quantum_info import Statevector\nstate = Statevector.from_instruction(qc)\nstate.draw('bloch')\n</pre> #Program 3.3b Show Bloch sphere of qubit w/ X-gate and H-gate from qiskit.quantum_info import Statevector state = Statevector.from_instruction(qc) state.draw('bloch') Out[6]: In\u00a0[7]: Copied! <pre>#Program 3.4 Measure state of qubit w/ H-gate\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nqc = QuantumCircuit(1,1)\nqc.h(0)\nqc.measure([0],[0])\nprint(\"This is |+&gt;:\")\nprint(qc)\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 3.4 Measure state of qubit w/ H-gate from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram qc = QuantumCircuit(1,1) qc.h(0) qc.measure([0],[0]) print(\"This is |+&gt;:\") print(qc) sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>This is |+&gt;:\n     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n  q: \u2524 H \u251c\u2524M\u251c\n     \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\nc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\n           0 \nCounts: {'0': 480, '1': 520}\n</pre> Out[7]: In\u00a0[8]: Copied! <pre>#Program 3.5 Measure state of qubit w/ X-gate and H-gate\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nqc = QuantumCircuit(1,1)\nqc.x(0)\nqc.h(0)\nqc.measure([0],[0])\nprint(\"This is |-&gt;:\")\nprint(qc)\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 3.5 Measure state of qubit w/ X-gate and H-gate from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram qc = QuantumCircuit(1,1) qc.x(0) qc.h(0) qc.measure([0],[0]) print(\"This is |-&gt;:\") print(qc) sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>This is |-&gt;:\n     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n  q: \u2524 X \u251c\u2524 H \u251c\u2524M\u251c\n     \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\nc: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\n                0 \nCounts: {'0': 488, '1': 512}\n</pre> Out[8]: In\u00a0[9]: Copied! <pre>#Program 3.6 Measure state of qubit w/ H-gate\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nqc = QuantumCircuit(2,2)\nqc.h(0)\nqc.h(1)\nqc.measure([0,1],[0,1])\nprint(\"This is |++&gt;:\")\nprint(qc)\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 3.6 Measure state of qubit w/ H-gate from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram qc = QuantumCircuit(2,2) qc.h(0) qc.h(1) qc.measure([0,1],[0,1]) print(\"This is |++&gt;:\") print(qc) sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>This is |++&gt;:\n     \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510   \nq_0: \u2524 H \u251c\u2524M\u251c\u2500\u2500\u2500\n     \u251c\u2500\u2500\u2500\u2524\u2514\u2565\u2518\u250c\u2500\u2510\nq_1: \u2524 H \u251c\u2500\u256b\u2500\u2524M\u251c\n     \u2514\u2500\u2500\u2500\u2518 \u2551 \u2514\u2565\u2518\nc: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n           0  1 \nCounts: {'01': 263, '11': 223, '00': 233, '10': 281}\n</pre> Out[9]: In\u00a0[10]: Copied! <pre>#Program 3.7a Apply X-, Y-, and Z-gate to qubit\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(3)\nqc.x(0)\nqc.y(1)\nqc.z(2)\nqc.draw('mpl')\n</pre> #Program 3.7a Apply X-, Y-, and Z-gate to qubit from qiskit import QuantumCircuit qc = QuantumCircuit(3) qc.x(0) qc.y(1) qc.z(2) qc.draw('mpl') Out[10]: In\u00a0[11]: Copied! <pre>#Program 3.7b Show Bloch sphere of qubit w/ X-, Y-, and Z-gate\nfrom qiskit.quantum_info import Statevector\nstate = Statevector.from_instruction(qc)\nstate.draw('bloch')\n</pre> #Program 3.7b Show Bloch sphere of qubit w/ X-, Y-, and Z-gate from qiskit.quantum_info import Statevector state = Statevector.from_instruction(qc) state.draw('bloch') Out[11]: In\u00a0[12]: Copied! <pre>#Program 3.8a Apply RX-, RY-, and RZ-gate to qubit\nfrom qiskit import QuantumCircuit\nimport math\nqc = QuantumCircuit(3)\nqc.rx(math.pi/2, 0)\nqc.ry(math.pi/2, 1)\nqc.rz(math.pi/2, 2)\nqc.draw('mpl')\n</pre> #Program 3.8a Apply RX-, RY-, and RZ-gate to qubit from qiskit import QuantumCircuit import math qc = QuantumCircuit(3) qc.rx(math.pi/2, 0) qc.ry(math.pi/2, 1) qc.rz(math.pi/2, 2) qc.draw('mpl') Out[12]: In\u00a0[13]: Copied! <pre>#Program 3.8b Show Bloch sphere of qubit w/ RX-, RY-, and RZ-gate\nfrom qiskit.quantum_info import Statevector\nstate = Statevector.from_instruction(qc)\nstate.draw('bloch')\n</pre> #Program 3.8b Show Bloch sphere of qubit w/ RX-, RY-, and RZ-gate from qiskit.quantum_info import Statevector state = Statevector.from_instruction(qc) state.draw('bloch') Out[13]: In\u00a0[14]: Copied! <pre>#Program 3.9a Apply RX-, P-, S-, T-gate to qubit\nfrom qiskit import QuantumCircuit\nimport math\nqc = QuantumCircuit(4)\nqc.rx(math.pi/2, [0,1,2,3])\nqc.p(math.pi/8, 1)\nqc.s(2)\nqc.t(3)\nqc.draw('mpl')\n</pre> #Program 3.9a Apply RX-, P-, S-, T-gate to qubit from qiskit import QuantumCircuit import math qc = QuantumCircuit(4) qc.rx(math.pi/2, [0,1,2,3]) qc.p(math.pi/8, 1) qc.s(2) qc.t(3) qc.draw('mpl') Out[14]: In\u00a0[15]: Copied! <pre>#Program 3.9b Show Bloch sphere of qubit w/ RX-, P-, S-, and T-gate\nfrom qiskit.quantum_info import Statevector\nstate = Statevector.from_instruction(qc)\nstate.draw('bloch')\n</pre> #Program 3.9b Show Bloch sphere of qubit w/ RX-, P-, S-, and T-gate from qiskit.quantum_info import Statevector state = Statevector.from_instruction(qc) state.draw('bloch') Out[15]: In\u00a0[16]: Copied! <pre>#Program 3.10a Apply RX-, I-, and U-gate to qubit\nfrom qiskit import QuantumCircuit\nimport math\nqc = QuantumCircuit(4)\nqc.rx(math.pi/2, [0,1,2,3])\nqc.i(1)\nqc.u(math.pi/2, 0, math.pi, 2)\nqc.u(0,0, math.pi/4, 3)\nqc.draw('mpl')\n</pre> #Program 3.10a Apply RX-, I-, and U-gate to qubit from qiskit import QuantumCircuit import math qc = QuantumCircuit(4) qc.rx(math.pi/2, [0,1,2,3]) qc.i(1) qc.u(math.pi/2, 0, math.pi, 2) qc.u(0,0, math.pi/4, 3) qc.draw('mpl') Out[16]: In\u00a0[17]: Copied! <pre>#Program 3.10b Show Bloch sphere of qubit w/ RX-, I-, and U-gate\nfrom qiskit.quantum_info import Statevector\nstate = Statevector.from_instruction(qc)\nstate.draw('bloch')\n</pre> #Program 3.10b Show Bloch sphere of qubit w/ RX-, I-, and U-gate from qiskit.quantum_info import Statevector state = Statevector.from_instruction(qc) state.draw('bloch') Out[17]:"},{"location":"quantum_computing/Code-Ch3/#3","title":"\u7b2c3\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc\u00b6","text":""},{"location":"quantum_computing/Code-Ch4/","title":"\u7b2c4\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc","text":"In\u00a0[1]: Copied! <pre>#Program 4.1 Apply CX-gate to qubit\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(2)\nqc.cx(0,1)\nqc.draw('mpl')\n</pre> #Program 4.1 Apply CX-gate to qubit from qiskit import QuantumCircuit qc = QuantumCircuit(2) qc.cx(0,1) qc.draw('mpl') Out[1]: In\u00a0[2]: Copied! <pre>#Program 4.2 Show unitary matrix of CX-gate (MSB as target bit)\nfrom qiskit import QuantumCircuit, Aer\nfrom qiskit.visualization import array_to_latex\nqc = QuantumCircuit(2)\nqc.cx(0,1)\ndisplay(qc.draw('mpl'))\nsim = Aer.get_backend('aer_simulator')\nqc.save_unitary()\nunitary = sim.run(qc).result().get_unitary()\ndisplay(array_to_latex(unitary, prefix=\"\\\\text{CNOT (MSB as target bit) = }\"))\n</pre> #Program 4.2 Show unitary matrix of CX-gate (MSB as target bit) from qiskit import QuantumCircuit, Aer from qiskit.visualization import array_to_latex qc = QuantumCircuit(2) qc.cx(0,1) display(qc.draw('mpl')) sim = Aer.get_backend('aer_simulator') qc.save_unitary() unitary = sim.run(qc).result().get_unitary() display(array_to_latex(unitary, prefix=\"\\\\text{CNOT (MSB as target bit) = }\"))  $$ \\text{CNOT (MSB as target bit) = } \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 1  \\\\  0 &amp; 0 &amp; 1 &amp; 0  \\\\  0 &amp; 1 &amp; 0 &amp; 0  \\\\  \\end{bmatrix} $$  In\u00a0[3]: Copied! <pre>#Program 4.3 Show unitary matrix of CX-gate (LSB as target bit)\nfrom qiskit import QuantumCircuit, Aer\nfrom qiskit.visualization import array_to_latex\nsim = Aer.get_backend('aer_simulator')\nqc = QuantumCircuit(2)\nqc.cx(1,0)\ndisplay(qc.draw('mpl'))\nqc.save_unitary()\nunitary = sim.run(qc).result().get_unitary()\ndisplay(array_to_latex(unitary, prefix=\"\\\\text{CNOT (LSB as target bit) = }\"))\n</pre> #Program 4.3 Show unitary matrix of CX-gate (LSB as target bit) from qiskit import QuantumCircuit, Aer from qiskit.visualization import array_to_latex sim = Aer.get_backend('aer_simulator') qc = QuantumCircuit(2) qc.cx(1,0) display(qc.draw('mpl')) qc.save_unitary() unitary = sim.run(qc).result().get_unitary() display(array_to_latex(unitary, prefix=\"\\\\text{CNOT (LSB as target bit) = }\"))  $$ \\text{CNOT (LSB as target bit) = } \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 1 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 1  \\\\  0 &amp; 0 &amp; 1 &amp; 0  \\\\  \\end{bmatrix} $$  In\u00a0[4]: Copied! <pre>#Program 4.4a Appliy CX-gate to qubit\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.quantum_info import Statevector\nqc = QuantumCircuit(8,8)\nsv = Statevector.from_label('11011000')\nqc.initialize(sv,range(8))\nqc.cx(0,1)\nqc.cx(2,3)\nqc.cx(4,5)\nqc.cx(6,7)\nqc.measure(range(8),range(8))\nqc.draw('mpl')\n</pre> #Program 4.4a Appliy CX-gate to qubit from qiskit import QuantumCircuit,execute from qiskit.quantum_info import Statevector qc = QuantumCircuit(8,8) sv = Statevector.from_label('11011000') qc.initialize(sv,range(8)) qc.cx(0,1) qc.cx(2,3) qc.cx(4,5) qc.cx(6,7) qc.measure(range(8),range(8)) qc.draw('mpl') Out[4]: In\u00a0[5]: Copied! <pre>#Program 4.4b Measure state of qubit w/ CX-gate\nfrom qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 4.4b Measure state of qubit w/ CX-gate from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>Counts: {'01111000': 1000}\n</pre> Out[5]: In\u00a0[6]: Copied! <pre>#Program 4.5 Build Bell state via H- and CX-gate\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(2)\nqc.h(1)\nqc.cx(1,0)\nprint(\"Below is the Bell state (top: q0 for target; bottom: q1 for control):\")\ndisplay(qc.draw('mpl'))\nprint(\"Below is the Bell state (top: q1 for control; bottom: q0 for traget):\")      \ndisplay(qc.draw('mpl',reverse_bits=True))\n</pre> #Program 4.5 Build Bell state via H- and CX-gate from qiskit import QuantumCircuit qc = QuantumCircuit(2) qc.h(1) qc.cx(1,0) print(\"Below is the Bell state (top: q0 for target; bottom: q1 for control):\") display(qc.draw('mpl')) print(\"Below is the Bell state (top: q1 for control; bottom: q0 for traget):\")       display(qc.draw('mpl',reverse_bits=True)) <pre>Below is the Bell state (top: q0 for target; bottom: q1 for control):\n</pre> <pre>Below is the Bell state (top: q1 for control; bottom: q0 for traget):\n</pre> In\u00a0[7]: Copied! <pre>#Program 4.6a Build Bell state via H- and CX-gate\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(2,2)\nqc.h(0)\nqc.cx(0,1)\nqc.measure(range(2),range(2))\nqc.draw('mpl')\n</pre> #Program 4.6a Build Bell state via H- and CX-gate from qiskit import QuantumCircuit qc = QuantumCircuit(2,2) qc.h(0) qc.cx(0,1) qc.measure(range(2),range(2)) qc.draw('mpl') Out[7]: In\u00a0[8]: Copied! <pre>#Program 4.6b Measure state of qubit in Bell state\nfrom qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 4.6b Measure state of qubit in Bell state from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>Counts: {'11': 500, '00': 500}\n</pre> Out[8]: In\u00a0[9]: Copied! <pre>#Program 4.7a Iinitialize qubit and build Bell state via H- and CX-gate\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info import Statevector\nqc = QuantumCircuit(2,2)\nsv = Statevector.from_label('10')\nqc.initialize(sv,range(2))\nqc.h(0)\nqc.cx(0,1)\nqc.measure(range(2),range(2))\nqc.draw('mpl')\n</pre> #Program 4.7a Iinitialize qubit and build Bell state via H- and CX-gate from qiskit import QuantumCircuit from qiskit.quantum_info import Statevector qc = QuantumCircuit(2,2) sv = Statevector.from_label('10') qc.initialize(sv,range(2)) qc.h(0) qc.cx(0,1) qc.measure(range(2),range(2)) qc.draw('mpl') Out[9]: In\u00a0[10]: Copied! <pre>#Program 4.7b Measure state of qubit in Bell state\nfrom qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 4.7b Measure state of qubit in Bell state from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>Counts: {'01': 493, '10': 507}\n</pre> Out[10]: In\u00a0[11]: Copied! <pre>#Program 4.8 Show quantum circuit for quantum teleportation\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nqs = QuantumRegister(1,'qs')\nqa = QuantumRegister(1,'qa')\nqb = QuantumRegister(1,'qb')\ncr = ClassicalRegister(2,'c')\nqc = QuantumCircuit(qs,qa,qb,cr)\nqc.h(qa)\nqc.cx(qa,qb)\nqc.barrier()\nqc.cx(qs,qa)\nqc.h(qs)\nqc.measure(qs,0)\nqc.measure(qa,1)\nqc.barrier()\nqc.x(qb)\nqc.z(qb)\nqc.draw('mpl')\n</pre> #Program 4.8 Show quantum circuit for quantum teleportation from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit qs = QuantumRegister(1,'qs') qa = QuantumRegister(1,'qa') qb = QuantumRegister(1,'qb') cr = ClassicalRegister(2,'c') qc = QuantumCircuit(qs,qa,qb,cr) qc.h(qa) qc.cx(qa,qb) qc.barrier() qc.cx(qs,qa) qc.h(qs) qc.measure(qs,0) qc.measure(qa,1) qc.barrier() qc.x(qb) qc.z(qb) qc.draw('mpl') Out[11]: In\u00a0[12]: Copied! <pre>#Program 4.9 Apply CX-, CY-, CZ-, CH-, and SWAP-gate to qubit \nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(12)\nqc.cx(0,1)\nqc.cy(2,3)\nqc.cz(4,5)\nqc.ch(6,7)\nqc.swap(8,9)\nqc.cx(10,11)\nqc.cx(11,10)\nqc.cx(10,11)\nqc.draw('mpl')\n</pre> #Program 4.9 Apply CX-, CY-, CZ-, CH-, and SWAP-gate to qubit  from qiskit import QuantumCircuit qc = QuantumCircuit(12) qc.cx(0,1) qc.cy(2,3) qc.cz(4,5) qc.ch(6,7) qc.swap(8,9) qc.cx(10,11) qc.cx(11,10) qc.cx(10,11) qc.draw('mpl') Out[12]: In\u00a0[13]: Copied! <pre>#Program 4.10 Apply CCX-gate to qubit\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(3)\nqc.ccx(0,1,2)\nqc.draw('mpl')\n</pre> #Program 4.10 Apply CCX-gate to qubit from qiskit import QuantumCircuit qc = QuantumCircuit(3) qc.ccx(0,1,2) qc.draw('mpl') Out[13]: In\u00a0[14]: Copied! <pre>#Program 4.11 Show unitary matrix of CCX-gate\nfrom qiskit import QuantumCircuit, Aer\nfrom qiskit.visualization import array_to_latex\nsim = Aer.get_backend('aer_simulator')\nqc1 = QuantumCircuit(3)\nqc1.ccx(0,1,2)\nprint(\"=\"*70,\"\\nBelow is quantum circuit of CCNOT gate (MSB as target bit):\")\ndisplay(qc1.draw('mpl'))\nqc1.save_unitary()\nunitary = sim.run(qc1).result().get_unitary()\ndisplay(array_to_latex(unitary, prefix=\"\\\\text{CCNOT (MSB as target bit) = }\\n\"))\nqc2 = QuantumCircuit(3)\nqc2.ccx(2,1,0)\nprint(\"=\"*70,\"\\nBelow is quantum circuit of CCNOT gate (LSB as target bit):\")\ndisplay(qc2.draw('mpl'))\nqc2.save_unitary()\nunitary = sim.run(qc2).result().get_unitary()\ndisplay(array_to_latex(unitary, prefix=\"\\\\text{CCNOT (LSB as target bit) = }\\n\"))\n</pre> #Program 4.11 Show unitary matrix of CCX-gate from qiskit import QuantumCircuit, Aer from qiskit.visualization import array_to_latex sim = Aer.get_backend('aer_simulator') qc1 = QuantumCircuit(3) qc1.ccx(0,1,2) print(\"=\"*70,\"\\nBelow is quantum circuit of CCNOT gate (MSB as target bit):\") display(qc1.draw('mpl')) qc1.save_unitary() unitary = sim.run(qc1).result().get_unitary() display(array_to_latex(unitary, prefix=\"\\\\text{CCNOT (MSB as target bit) = }\\n\")) qc2 = QuantumCircuit(3) qc2.ccx(2,1,0) print(\"=\"*70,\"\\nBelow is quantum circuit of CCNOT gate (LSB as target bit):\") display(qc2.draw('mpl')) qc2.save_unitary() unitary = sim.run(qc2).result().get_unitary() display(array_to_latex(unitary, prefix=\"\\\\text{CCNOT (LSB as target bit) = }\\n\")) <pre>====================================================================== \nBelow is quantum circuit of CCNOT gate (MSB as target bit):\n</pre>  $$ \\text{CCNOT (MSB as target bit) = }  \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  \\\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\  \\end{bmatrix} $$  <pre>====================================================================== \nBelow is quantum circuit of CCNOT gate (LSB as target bit):\n</pre>  $$ \\text{CCNOT (LSB as target bit) = }  \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  \\\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0  \\\\  \\end{bmatrix} $$  In\u00a0[15]: Copied! <pre>#Program 4.12 Apply CCCCX-gate to qubit\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(7)\nqc.ccx(0,1,4)\nqc.ccx(2,3,5)\nqc.ccx(4,5,6)\nqc.draw('mpl')\n</pre> #Program 4.12 Apply CCCCX-gate to qubit from qiskit import QuantumCircuit qc = QuantumCircuit(7) qc.ccx(0,1,4) qc.ccx(2,3,5) qc.ccx(4,5,6) qc.draw('mpl') Out[15]:"},{"location":"quantum_computing/Code-Ch4/#4","title":"\u7b2c4\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc\u00b6","text":""},{"location":"quantum_computing/Code-Ch5/","title":"\u7b2c5\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc","text":"In\u00a0[1]: Copied! <pre>#program 5.1a Define classical oracle f1 and test it\ndef f1(x):\n  return '1'\nprint(f1('000'),f1('001'),f1('010'),f1('011'),f1('100'),f1('101'),f1('110'),f1('111'))\n</pre> #program 5.1a Define classical oracle f1 and test it def f1(x):   return '1' print(f1('000'),f1('001'),f1('010'),f1('011'),f1('100'),f1('101'),f1('110'),f1('111')) <pre>1 1 1 1 1 1 1 1\n</pre> In\u00a0[2]: Copied! <pre>#program 5.1b Define classical oracle f2 and test it\ndef f2(x):\n  if x[0]=='0':\n    return '0'\n  else:\n    return '1'\nprint(f2('000'),f2('001'),f2('010'),f2('011'),f2('100'),f2('101'),f2('110'),f2('111'))\n</pre> #program 5.1b Define classical oracle f2 and test it def f2(x):   if x[0]=='0':     return '0'   else:     return '1' print(f2('000'),f2('001'),f2('010'),f2('011'),f2('100'),f2('101'),f2('110'),f2('111')) <pre>0 0 0 0 1 1 1 1\n</pre> In\u00a0[3]: Copied! <pre>#Program 5.1c Solve constant-balanced function decision (CBFD) prob. with classical code\nimport itertools\ndef cbfd_test(f,n):\n  count0=count1=0\n  iter = itertools.product([0,1], repeat=n)\n  lst = [''.join(map(str, item)) for item in iter]\n  for s in lst:\n    if f(s)=='0':      \n      count0+=1\n    else:        \n      count1+=1\n    if count0&gt;0 and count1&gt;0:\n      return True  #for balanced function\n    elif count0&gt;2**(n-1) or count1&gt;2**(n-1):\n      return False #for constant function\nprint(cbfd_test(f1,3))\nprint(cdfd_test(f2,3))\n</pre> #Program 5.1c Solve constant-balanced function decision (CBFD) prob. with classical code import itertools def cbfd_test(f,n):   count0=count1=0   iter = itertools.product([0,1], repeat=n)   lst = [''.join(map(str, item)) for item in iter]   for s in lst:     if f(s)=='0':             count0+=1     else:               count1+=1     if count0&gt;0 and count1&gt;0:       return True  #for balanced function     elif count0&gt;2**(n-1) or count1&gt;2**(n-1):       return False #for constant function print(cbfd_test(f1,3)) print(cdfd_test(f2,3)) <pre>False\n</pre> <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 17\n     15       return False #for constant function\n     16 print(cbfd_test(f1,3))\n---&gt; 17 print(cdfd_test(f2,3))\n\nNameError: name 'cdfd_test' is not defined</pre> In\u00a0[4]: Copied! <pre>#Program 5.2 Define a quantum oracle\nfrom qiskit import QuantumRegister,QuantumCircuit\nqrx = QuantumRegister(3,'x')\nqry = QuantumRegister(1,'y')\nqc = QuantumCircuit(qrx,qry)\nqc.x(qry)\nqc.draw('mpl')\n</pre> #Program 5.2 Define a quantum oracle from qiskit import QuantumRegister,QuantumCircuit qrx = QuantumRegister(3,'x') qry = QuantumRegister(1,'y') qc = QuantumCircuit(qrx,qry) qc.x(qry) qc.draw('mpl') Out[4]: In\u00a0[5]: Copied! <pre>#Program 5.3a Build quantum circuit of Deutsch-Jozsa alg.\nfrom qiskit import QuantumRegister,ClassicalRegister,QuantumCircuit\nqrx = QuantumRegister(3,'x')\nqry = QuantumRegister(1,'y')\ncr = ClassicalRegister(3,'c')\nqc = QuantumCircuit(qrx,qry,cr)\nqc.h(qrx)\nqc.x(qry)\nqc.h(qry)\nqc.barrier()\nqc.x(qry)\nqc.barrier()\nqc.h(qrx)\nqc.measure(qrx,cr)\nqc.draw('mpl')\n</pre> #Program 5.3a Build quantum circuit of Deutsch-Jozsa alg. from qiskit import QuantumRegister,ClassicalRegister,QuantumCircuit qrx = QuantumRegister(3,'x') qry = QuantumRegister(1,'y') cr = ClassicalRegister(3,'c') qc = QuantumCircuit(qrx,qry,cr) qc.h(qrx) qc.x(qry) qc.h(qry) qc.barrier() qc.x(qry) qc.barrier() qc.h(qrx) qc.measure(qrx,cr) qc.draw('mpl') Out[5]: In\u00a0[6]: Copied! <pre>#Program 5.3b Run Deutsch-Jozsa alg. with simulator\nfrom qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 5.3b Run Deutsch-Jozsa alg. with simulator from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>Counts: {'000': 1000}\n</pre> Out[6]: In\u00a0[7]: Copied! <pre>#Program 5.4 Define another quantum oracle\nfrom qiskit import QuantumRegister,QuantumCircuit\nqrx = QuantumRegister(3,'x')\nqry = QuantumRegister(1,'y')\nqc = QuantumCircuit(qrx,qry)\nqc.cx(qrx[0],qry)\nqc.draw('mpl')\n</pre> #Program 5.4 Define another quantum oracle from qiskit import QuantumRegister,QuantumCircuit qrx = QuantumRegister(3,'x') qry = QuantumRegister(1,'y') qc = QuantumCircuit(qrx,qry) qc.cx(qrx[0],qry) qc.draw('mpl') Out[7]: In\u00a0[8]: Copied! <pre>#Program 5.5a Build quantum circuit of Deutsch-Jozsa alg.\nfrom qiskit import QuantumRegister,ClassicalRegister,QuantumCircuit\nqrx = QuantumRegister(3,'x')\nqry = QuantumRegister(1,'y')\ncr = ClassicalRegister(3,'c')\nqc = QuantumCircuit(qrx,qry,cr)\nqc.h(qrx)\nqc.x(qry)\nqc.h(qry)\nqc.barrier()\nqc.cx(qrx[0],qry)\nqc.barrier()\nqc.h(qrx)\nqc.measure(qrx,cr)\nqc.draw('mpl')\n</pre> #Program 5.5a Build quantum circuit of Deutsch-Jozsa alg. from qiskit import QuantumRegister,ClassicalRegister,QuantumCircuit qrx = QuantumRegister(3,'x') qry = QuantumRegister(1,'y') cr = ClassicalRegister(3,'c') qc = QuantumCircuit(qrx,qry,cr) qc.h(qrx) qc.x(qry) qc.h(qry) qc.barrier() qc.cx(qrx[0],qry) qc.barrier() qc.h(qrx) qc.measure(qrx,cr) qc.draw('mpl') Out[8]: In\u00a0[9]: Copied! <pre>#Program 5.5b Run Deutsch-Jozsa alg. with simulator\nfrom qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nsim=AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult=job.result()\ncounts=result.get_counts(qc)\nprint(\"Counts:\",counts)\nplot_histogram(counts)\n</pre> #Program 5.5b Run Deutsch-Jozsa alg. with simulator from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram sim=AerSimulator() job=execute(qc, backend=sim, shots=1000) result=job.result() counts=result.get_counts(qc) print(\"Counts:\",counts) plot_histogram(counts) <pre>Counts: {'001': 1000}\n</pre> Out[9]: In\u00a0[10]: Copied! <pre>#Program 5.6 Show phase kickback of CNOT gate\nfrom qiskit import QuantumCircuit, Aer\nfrom qiskit.visualization import array_to_latex, plot_bloch_multivector \nsim = Aer.get_backend('aer_simulator')\nqc1 = QuantumCircuit(2)\nqc1.h(0)\nqc1.x(1)\nqc1.h(1)\nqc1.save_statevector()\nstate1 = sim.run(qc1).result().get_statevector()\ndisplay(qc1.draw('mpl'))\ndisplay(array_to_latex(state1, prefix='\\\\text{Statevector before CNOT gate: }'))\ndisplay(plot_bloch_multivector(state1))\nprint('='*60)\nqc2 = QuantumCircuit(2)\nqc2.h(0)\nqc2.x(1)\nqc2.h(1)\nqc2.cx(0,1)\nqc2.save_statevector()\nstate2 = sim.run(qc2).result().get_statevector()\ndisplay(qc2.draw('mpl'))\ndisplay(array_to_latex(state2, prefix='\\\\text{Statevector after CNOT gate: }'))\ndisplay(plot_bloch_multivector(state2))\n</pre> #Program 5.6 Show phase kickback of CNOT gate from qiskit import QuantumCircuit, Aer from qiskit.visualization import array_to_latex, plot_bloch_multivector  sim = Aer.get_backend('aer_simulator') qc1 = QuantumCircuit(2) qc1.h(0) qc1.x(1) qc1.h(1) qc1.save_statevector() state1 = sim.run(qc1).result().get_statevector() display(qc1.draw('mpl')) display(array_to_latex(state1, prefix='\\\\text{Statevector before CNOT gate: }')) display(plot_bloch_multivector(state1)) print('='*60) qc2 = QuantumCircuit(2) qc2.h(0) qc2.x(1) qc2.h(1) qc2.cx(0,1) qc2.save_statevector() state2 = sim.run(qc2).result().get_statevector() display(qc2.draw('mpl')) display(array_to_latex(state2, prefix='\\\\text{Statevector after CNOT gate: }')) display(plot_bloch_multivector(state2))  $$ \\text{Statevector before CNOT gate: } \\begin{bmatrix} \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; - \\frac{1}{2}  \\\\  \\end{bmatrix} $$  <pre>============================================================\n</pre>  $$ \\text{Statevector after CNOT gate: } \\begin{bmatrix} \\frac{1}{2} &amp; - \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2}  \\\\  \\end{bmatrix} $$  In\u00a0[11]: Copied! <pre># Program 5.7 Show phase kickback of CCNOT gate\nfrom qiskit import QuantumCircuit, Aer\nfrom qiskit.visualization import array_to_latex, plot_bloch_multivector\nsim = Aer.get_backend('aer_simulator')\nqc1 = QuantumCircuit(3)\nqc1.h([0,1])\nqc1.x(2)\nqc1.h(2)\nqc1.save_statevector()\nstate1 = sim.run(qc1).result().get_statevector()\ndisplay(qc1.draw('mpl'))\ndisplay(array_to_latex(state1, prefix=\"\\\\text{Statevector before CCNOT gate: }\"))\ndisplay(plot_bloch_multivector(state1))\nprint('='*80)\nqc2 = QuantumCircuit(3)\nqc2.h([0,1])\nqc2.x(2)\nqc2.h(2)\nqc2.ccx(0,1,2)\nqc2.save_statevector()\nstate2 = sim.run(qc2).result().get_statevector()\ndisplay(qc2.draw('mpl'))\ndisplay(array_to_latex(state2, prefix=\"\\\\text{Statevector before CCNOT gate: }\"))\ndisplay(plot_bloch_multivector(state2))\n</pre> # Program 5.7 Show phase kickback of CCNOT gate from qiskit import QuantumCircuit, Aer from qiskit.visualization import array_to_latex, plot_bloch_multivector sim = Aer.get_backend('aer_simulator') qc1 = QuantumCircuit(3) qc1.h([0,1]) qc1.x(2) qc1.h(2) qc1.save_statevector() state1 = sim.run(qc1).result().get_statevector() display(qc1.draw('mpl')) display(array_to_latex(state1, prefix=\"\\\\text{Statevector before CCNOT gate: }\")) display(plot_bloch_multivector(state1)) print('='*80) qc2 = QuantumCircuit(3) qc2.h([0,1]) qc2.x(2) qc2.h(2) qc2.ccx(0,1,2) qc2.save_statevector() state2 = sim.run(qc2).result().get_statevector() display(qc2.draw('mpl')) display(array_to_latex(state2, prefix=\"\\\\text{Statevector before CCNOT gate: }\")) display(plot_bloch_multivector(state2))  $$ \\text{Statevector before CCNOT gate: } \\begin{bmatrix} \\frac{\\sqrt{2}}{4} &amp; \\frac{\\sqrt{2}}{4} &amp; \\frac{\\sqrt{2}}{4} &amp; \\frac{\\sqrt{2}}{4} &amp; - \\frac{\\sqrt{2}}{4} &amp; - \\frac{\\sqrt{2}}{4} &amp; - \\frac{\\sqrt{2}}{4} &amp; - \\frac{\\sqrt{2}}{4}  \\\\  \\end{bmatrix} $$  <pre>================================================================================\n</pre>  $$ \\text{Statevector before CCNOT gate: } \\begin{bmatrix} \\frac{\\sqrt{2}}{4} &amp; \\frac{\\sqrt{2}}{4} &amp; \\frac{\\sqrt{2}}{4} &amp; - \\frac{\\sqrt{2}}{4} &amp; - \\frac{\\sqrt{2}}{4} &amp; - \\frac{\\sqrt{2}}{4} &amp; - \\frac{\\sqrt{2}}{4} &amp; \\frac{\\sqrt{2}}{4}  \\\\  \\end{bmatrix} $$  In\u00a0[12]: Copied! <pre>#Program 5.8 Show circuit containing CZ gate and CZ gate's unitary matrix\nfrom qiskit import QuantumCircuit, Aer\nfrom qiskit.visualization import array_to_latex\nsim = Aer.get_backend('aer_simulator')\nqc1 = QuantumCircuit(2)\nqc1.cz(0,1)\nqc1.save_unitary()\nunitary1 = sim.run(qc1).result().get_unitary()\nprint(\"CZ Gate (q0 as control bit, q1 as target bit):\")\ndisplay(qc1.draw('mpl'))\ndisplay(array_to_latex(unitary1, prefix=\"\\\\text{Unitray Matrix of CZ Gate (MSB as Target): }\"))\nprint('='*60)  \nqc2 = QuantumCircuit(2)\nqc2.cz(1,0)\nqc2.save_unitary()\nunitary2 = sim.run(qc2).result().get_unitary()\nprint(\"CZ Gate (q1 as control bit, q0 as target bit):\")\ndisplay(qc2.draw('mpl'))\ndisplay(array_to_latex(unitary2, prefix=\"\\\\text{Unitray Matrix of CZ Gate (LSB as Target): }\"))\n</pre> #Program 5.8 Show circuit containing CZ gate and CZ gate's unitary matrix from qiskit import QuantumCircuit, Aer from qiskit.visualization import array_to_latex sim = Aer.get_backend('aer_simulator') qc1 = QuantumCircuit(2) qc1.cz(0,1) qc1.save_unitary() unitary1 = sim.run(qc1).result().get_unitary() print(\"CZ Gate (q0 as control bit, q1 as target bit):\") display(qc1.draw('mpl')) display(array_to_latex(unitary1, prefix=\"\\\\text{Unitray Matrix of CZ Gate (MSB as Target): }\")) print('='*60)   qc2 = QuantumCircuit(2) qc2.cz(1,0) qc2.save_unitary() unitary2 = sim.run(qc2).result().get_unitary() print(\"CZ Gate (q1 as control bit, q0 as target bit):\") display(qc2.draw('mpl')) display(array_to_latex(unitary2, prefix=\"\\\\text{Unitray Matrix of CZ Gate (LSB as Target): }\")) <pre>CZ Gate (q0 as control bit, q1 as target bit):\n</pre>  $$ \\text{Unitray Matrix of CZ Gate (MSB as Target): } \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 1 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 1 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; -1  \\\\  \\end{bmatrix} $$  <pre>============================================================\nCZ Gate (q1 as control bit, q0 as target bit):\n</pre>  $$ \\text{Unitray Matrix of CZ Gate (LSB as Target): } \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0  \\\\  0 &amp; 1 &amp; 0 &amp; 0  \\\\  0 &amp; 0 &amp; 1 &amp; 0  \\\\  0 &amp; 0 &amp; 0 &amp; -1  \\\\  \\end{bmatrix} $$  In\u00a0[13]: Copied! <pre>#Program 5.9 Show quantum circuit with CZ, CP, CS, CT gates\nfrom qiskit import QuantumCircuit\nfrom math import pi\nqc = QuantumCircuit(8)\nqc.cz(0,1)\nqc.cp(pi,2,3)\nqc.cp(pi/2,4,5)\nqc.cp(pi/4,6,7)\ndisplay(qc.draw('mpl'))\n</pre> #Program 5.9 Show quantum circuit with CZ, CP, CS, CT gates from qiskit import QuantumCircuit from math import pi qc = QuantumCircuit(8) qc.cz(0,1) qc.cp(pi,2,3) qc.cp(pi/2,4,5) qc.cp(pi/4,6,7) display(qc.draw('mpl'))"},{"location":"quantum_computing/Code-Ch5/#5","title":"\u7b2c5\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc\u00b6","text":""},{"location":"quantum_computing/Code-Ch6/","title":"\u7b2c\u516d\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc","text":"In\u00a0[1]: Copied! <pre>#program 6.1a Define classical oracle f1 for unstructured search\ndef f1(x):\n  if x=='01':  \n    return '1'\n  else:\n    return '0'\nprint(f1('00'),f1('01'),f1('10'),f1('11'))\n</pre> #program 6.1a Define classical oracle f1 for unstructured search def f1(x):   if x=='01':       return '1'   else:     return '0' print(f1('00'),f1('01'),f1('10'),f1('11')) <pre>0 1 0 0\n</pre> In\u00a0[2]: Copied! <pre>#program 6.1b Define classical oracle f2 for unstructured search\ndef f2(x):\n  if x=='001':  \n    return '1'\n  else:\n    return '0'\nprint(f2('000'),f2('001'),f2('010'),f2('011'),f2('100'),f2('101'),f2('110'),f2('111'))\n</pre> #program 6.1b Define classical oracle f2 for unstructured search def f2(x):   if x=='001':       return '1'   else:     return '0' print(f2('000'),f2('001'),f2('010'),f2('011'),f2('100'),f2('101'),f2('110'),f2('111')) <pre>0 1 0 0 0 0 0 0\n</pre> In\u00a0[3]: Copied! <pre>#program 6.1c Define classical oracle f3 for unstructured search\ndef f3(x):\n  if x=='101':  \n    return '1'\n  else:\n    return '0'\nprint(f3('000'),f3('001'),f3('010'),f3('011'),f3('100'),f3('101'),f3('110'),f3('111'))\n</pre> #program 6.1c Define classical oracle f3 for unstructured search def f3(x):   if x=='101':       return '1'   else:     return '0' print(f3('000'),f3('001'),f3('010'),f3('011'),f3('100'),f3('101'),f3('110'),f3('111')) <pre>0 0 0 0 0 1 0 0\n</pre> In\u00a0[4]: Copied! <pre>#Program 6.1d Solve unstructured search prob. with classical code\nimport itertools\ndef unstructured_search(f,n):\n  iter = itertools.product([0,1], repeat=n)\n  lst = [''.join(map(str, item)) for item in iter]\n  for s in lst:\n    if f(s)=='1':      \n      return s\nprint(unstructured_search(f1,2))\nprint(unstructured_search(f2,3))\nprint(unstructured_search(f3,3))\n</pre> #Program 6.1d Solve unstructured search prob. with classical code import itertools def unstructured_search(f,n):   iter = itertools.product([0,1], repeat=n)   lst = [''.join(map(str, item)) for item in iter]   for s in lst:     if f(s)=='1':             return s print(unstructured_search(f1,2)) print(unstructured_search(f2,3)) print(unstructured_search(f3,3)) <pre>01\n001\n101\n</pre> In\u00a0[5]: Copied! <pre>#Program 6.2 Define quantum oracle for input solution='00'\nfrom qiskit import QuantumRegister,QuantumCircuit\nqrx = QuantumRegister(2,'x')\nqc = QuantumCircuit(qrx)\nqc.x([0,1])\nqc.cz(0,1)\nqc.x([0,1])\nprint(\"The quantum circuit of phase oracle for input solution='00':\")\nqc.draw('mpl')\n</pre> #Program 6.2 Define quantum oracle for input solution='00' from qiskit import QuantumRegister,QuantumCircuit qrx = QuantumRegister(2,'x') qc = QuantumCircuit(qrx) qc.x([0,1]) qc.cz(0,1) qc.x([0,1]) print(\"The quantum circuit of phase oracle for input solution='00':\") qc.draw('mpl') <pre>The quantum circuit of phase oracle for input solution='00':\n</pre> Out[5]: In\u00a0[6]: Copied! <pre>#Program 6.3 Define quantum oracle for input solution='01'\nfrom qiskit import QuantumRegister,QuantumCircuit\nqrx = QuantumRegister(2,'x')\nqc = QuantumCircuit(qrx)\nqc.x(1)\nqc.cz(0,1)\nqc.x(1)\nprint(\"The quantum circuit of phase oracle for input solution='01':\")\nqc.draw('mpl')\n</pre> #Program 6.3 Define quantum oracle for input solution='01' from qiskit import QuantumRegister,QuantumCircuit qrx = QuantumRegister(2,'x') qc = QuantumCircuit(qrx) qc.x(1) qc.cz(0,1) qc.x(1) print(\"The quantum circuit of phase oracle for input solution='01':\") qc.draw('mpl') <pre>The quantum circuit of phase oracle for input solution='01':\n</pre> Out[6]: In\u00a0[7]: Copied! <pre>#Program 6.4 Define quantum oracle for input solution='10'\nfrom qiskit import QuantumRegister,QuantumCircuit\nqrx = QuantumRegister(2,'x')\nqc = QuantumCircuit(qrx)\nqc.x(0)\nqc.cz(1,0)\nqc.x(0)\nprint(\"The quantum circuit of phase oracle for input solution='10':\")\nqc.draw('mpl')\n</pre> #Program 6.4 Define quantum oracle for input solution='10' from qiskit import QuantumRegister,QuantumCircuit qrx = QuantumRegister(2,'x') qc = QuantumCircuit(qrx) qc.x(0) qc.cz(1,0) qc.x(0) print(\"The quantum circuit of phase oracle for input solution='10':\") qc.draw('mpl') <pre>The quantum circuit of phase oracle for input solution='10':\n</pre> Out[7]: In\u00a0[8]: Copied! <pre>#Program 6.5 Define quantum oracle for input solution='11'\nfrom qiskit import QuantumRegister,QuantumCircuit\nqrx = QuantumRegister(2,'x')\nqc = QuantumCircuit(qrx)\nqc.cz(1,0)\nprint(\"The quantum circuit of phase oracle for input solution='11':\")\nqc.draw('mpl')\n</pre> #Program 6.5 Define quantum oracle for input solution='11' from qiskit import QuantumRegister,QuantumCircuit qrx = QuantumRegister(2,'x') qc = QuantumCircuit(qrx) qc.cz(1,0) print(\"The quantum circuit of phase oracle for input solution='11':\") qc.draw('mpl') <pre>The quantum circuit of phase oracle for input solution='11':\n</pre> Out[8]: In\u00a0[9]: Copied! <pre>#Program 6.6 Grover alg. with oracle for input solution='10'\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nqc = QuantumCircuit(2,2)\nqc.h([0,1])\nqc.barrier()\nqc.x(0)\nqc.cz(1,0)\nqc.x(0)\nqc.barrier()\nqc.h([0,1])\nqc.x([0,1])\nqc.cz(0,1)\nqc.x([0,1])\nqc.h([0,1])\nqc.barrier()\nqc.measure([0,1],[0,1])\nprint(\"The quantum circuit of Grover's algorithm for input solution='10':\")\ndisplay(qc.draw('mpl'))\nsim = AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\",counts)\ndisplay(plot_histogram(counts))\n</pre> #Program 6.6 Grover alg. with oracle for input solution='10' from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram qc = QuantumCircuit(2,2) qc.h([0,1]) qc.barrier() qc.x(0) qc.cz(1,0) qc.x(0) qc.barrier() qc.h([0,1]) qc.x([0,1]) qc.cz(0,1) qc.x([0,1]) qc.h([0,1]) qc.barrier() qc.measure([0,1],[0,1]) print(\"The quantum circuit of Grover's algorithm for input solution='10':\") display(qc.draw('mpl')) sim = AerSimulator() job=execute(qc, backend=sim, shots=1000) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\",counts) display(plot_histogram(counts)) <pre>The quantum circuit of Grover's algorithm for input solution='10':\n</pre> <pre>Total counts for qubit states are: {'10': 1000}\n</pre> In\u00a0[10]: Copied! <pre>#Program 6.7 Grover alg. with oracle for input solution='101'\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nfrom math import pi\nqc = QuantumCircuit(3,3)\nqc.h([0,1,2])\nqc.barrier()\nfor repeat in range(2):\n  qc.x(1)\n  qc.mcp(pi,[0,1],2)\n  qc.x(1)\n  qc.barrier()\n  qc.h([0,1,2])\n  qc.x([0,1,2])\n  qc.mcp(pi,[0,1],2)\n  qc.x([0,1,2])\n  qc.h([0,1,2])\n  qc.barrier()\nqc.measure([0,1,2],[0,1,2])\nprint(\"The quantum circuit of Grover's algorithm for input solution='101':\")\ndisplay(qc.draw('mpl'))\nsim = AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\",counts)\ndisplay(plot_histogram(counts))\n</pre> #Program 6.7 Grover alg. with oracle for input solution='101' from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram from math import pi qc = QuantumCircuit(3,3) qc.h([0,1,2]) qc.barrier() for repeat in range(2):   qc.x(1)   qc.mcp(pi,[0,1],2)   qc.x(1)   qc.barrier()   qc.h([0,1,2])   qc.x([0,1,2])   qc.mcp(pi,[0,1],2)   qc.x([0,1,2])   qc.h([0,1,2])   qc.barrier() qc.measure([0,1,2],[0,1,2]) print(\"The quantum circuit of Grover's algorithm for input solution='101':\") display(qc.draw('mpl')) sim = AerSimulator() job=execute(qc, backend=sim, shots=1000) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\",counts) display(plot_histogram(counts)) <pre>The quantum circuit of Grover's algorithm for input solution='101':\n</pre> <pre>Total counts for qubit states are: {'110': 9, '001': 8, '100': 9, '000': 9, '010': 13, '111': 13, '011': 8, '101': 931}\n</pre> In\u00a0[11]: Copied! <pre>#Program 6.8 Solve Hamiltonian cycle prob. for clique-4 with Grover alg.\nfrom qiskit import QuantumCircuit,execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nfrom math import pi\nqc = QuantumCircuit(6,6)\nqc.h(range(6))\nqc.barrier()\nfor repeat in range(3):\n  qc.x([4,5])\n  qc.mcp(pi,list(range(5)),5)\n  qc.x([4,5])\n  qc.barrier()\n  qc.x([1,3])\n  qc.mcp(pi,list(range(5)),5)\n  qc.x([1,3])\n  qc.barrier()\n  qc.x([0,2])\n  qc.mcp(pi,list(range(5)),5)\n  qc.x([0,2])\n  qc.barrier()\n  qc.h(range(6))\n  qc.x(range(6))\n  qc.mcp(pi,list(range(5)),5)\n  qc.x(range(6))\n  qc.h(range(6))\n  qc.barrier()\nqc.measure(range(6),range(6))\nprint(\"The quantum circuit of Grover's algorithm:\")\ndisplay(qc.draw('mpl'))\nsim = AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult = job.result()\ncounts = result.get_counts(qc)\ndisplay(plot_histogram(counts))\nprint(\"Total counts for qubit states are:\",counts)\nsorted_counts=sorted(counts.items(),key=lambda x:x[1], reverse=True)\nprint(\"The solutions to the Hamiltonian cycle problem are:\")\n#find_all_ones=lambda s:[x for x in range(s.find('1'), len(s)) if s[x]=='1']\nfind_all_ones=lambda s:[x for x in range(len(s)) if s[x]=='1']\nfor i in range(3):  #It is konw there are (4-1)!/2=3 solutions\n  scstr=sorted_counts[i][0] #scstr: string in sorted_counts\n  print(scstr,end=' (')\n  reverse_scstr=scstr[::-1] #reverse scstr for LSB at the right \n  all_ones=find_all_ones(reverse_scstr)\n  for one in all_ones[0:-1]:\n    print('e'+str(one)+'-&gt;',end='')\n  print('e'+str(all_ones[-1])+')')\n</pre> #Program 6.8 Solve Hamiltonian cycle prob. for clique-4 with Grover alg. from qiskit import QuantumCircuit,execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram from math import pi qc = QuantumCircuit(6,6) qc.h(range(6)) qc.barrier() for repeat in range(3):   qc.x([4,5])   qc.mcp(pi,list(range(5)),5)   qc.x([4,5])   qc.barrier()   qc.x([1,3])   qc.mcp(pi,list(range(5)),5)   qc.x([1,3])   qc.barrier()   qc.x([0,2])   qc.mcp(pi,list(range(5)),5)   qc.x([0,2])   qc.barrier()   qc.h(range(6))   qc.x(range(6))   qc.mcp(pi,list(range(5)),5)   qc.x(range(6))   qc.h(range(6))   qc.barrier() qc.measure(range(6),range(6)) print(\"The quantum circuit of Grover's algorithm:\") display(qc.draw('mpl')) sim = AerSimulator() job=execute(qc, backend=sim, shots=1000) result = job.result() counts = result.get_counts(qc) display(plot_histogram(counts)) print(\"Total counts for qubit states are:\",counts) sorted_counts=sorted(counts.items(),key=lambda x:x[1], reverse=True) print(\"The solutions to the Hamiltonian cycle problem are:\") #find_all_ones=lambda s:[x for x in range(s.find('1'), len(s)) if s[x]=='1'] find_all_ones=lambda s:[x for x in range(len(s)) if s[x]=='1'] for i in range(3):  #It is konw there are (4-1)!/2=3 solutions   scstr=sorted_counts[i][0] #scstr: string in sorted_counts   print(scstr,end=' (')   reverse_scstr=scstr[::-1] #reverse scstr for LSB at the right    all_ones=find_all_ones(reverse_scstr)   for one in all_ones[0:-1]:     print('e'+str(one)+'-&gt;',end='')   print('e'+str(all_ones[-1])+')')                        <pre>The quantum circuit of Grover's algorithm:\n</pre> <pre>Total counts for qubit states are: {'011101': 1, '111010': 358, '110101': 301, '001111': 340}\nThe solutions to the Hamiltonian cycle problem are:\n111010 (e1-&gt;e3-&gt;e4-&gt;e5)\n001111 (e0-&gt;e1-&gt;e2-&gt;e3)\n110101 (e0-&gt;e2-&gt;e4-&gt;e5)\n</pre>"},{"location":"quantum_computing/Code-Ch6/","title":"\u7b2c\u516d\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc\u00b6","text":""},{"location":"quantum_computing/Code-Ch7/","title":"\u7b2c7\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc:","text":"In\u00a0[1]: Copied! <pre>#Program 7.1 Show Bloch sphere for computational basis and Fourier basis\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.quantum_info import Statevector\nprint('='*60,'\\nBelow are computational bases:')\ncb = QuantumRegister(2,'computational_basis')\nqc1 = QuantumCircuit(cb)\nqc1.x(1)\ndisplay(qc1.draw('mpl'))\nstate1 = Statevector.from_instruction(qc1)\ndisplay(state1.draw('bloch'))\nprint('='*60,'\\nBelow are Fourier bases:')\nfb = QuantumRegister(2,'fourier_basis')\nqc2 = QuantumCircuit(fb)\nqc2.x(1)\nqc2.h([0,1])\ndisplay(qc2.draw('mpl'))\nstate2 = Statevector.from_instruction(qc2)\ndisplay(state2.draw('bloch'))\n</pre> #Program 7.1 Show Bloch sphere for computational basis and Fourier basis from qiskit import QuantumRegister, QuantumCircuit from qiskit.quantum_info import Statevector print('='*60,'\\nBelow are computational bases:') cb = QuantumRegister(2,'computational_basis') qc1 = QuantumCircuit(cb) qc1.x(1) display(qc1.draw('mpl')) state1 = Statevector.from_instruction(qc1) display(state1.draw('bloch')) print('='*60,'\\nBelow are Fourier bases:') fb = QuantumRegister(2,'fourier_basis') qc2 = QuantumCircuit(fb) qc2.x(1) qc2.h([0,1]) display(qc2.draw('mpl')) state2 = Statevector.from_instruction(qc2) display(state2.draw('bloch')) <pre>============================================================ \nBelow are computational bases:\n</pre> <pre>============================================================ \nBelow are Fourier bases:\n</pre> In\u00a0[2]: Copied! <pre>#Program 7.2 Build 2-qubit QFT quantum circuit\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom math import pi\nar = QuantumRegister(2,'a')\nqc = QuantumCircuit(ar)\nqc.h(1)\nqc.cp(pi/2, 0, 1)\nqc.h(0)\nqc.swap(0,1)\nprint('Below is the quantum Fourier transform (QFT) circuit:')\ndisplay(qc.draw('mpl'))\n</pre> #Program 7.2 Build 2-qubit QFT quantum circuit from qiskit import QuantumRegister, QuantumCircuit from math import pi ar = QuantumRegister(2,'a') qc = QuantumCircuit(ar) qc.h(1) qc.cp(pi/2, 0, 1) qc.h(0) qc.swap(0,1) print('Below is the quantum Fourier transform (QFT) circuit:') display(qc.draw('mpl')) <pre>Below is the quantum Fourier transform (QFT) circuit:\n</pre> In\u00a0[3]: Copied! <pre>#Program 7.3 Apply QFT to qubit with various initial state\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.quantum_info import Statevector\nfrom qiskit.visualization import array_to_latex\nfrom math import pi\ntwo_bits = ['00','01','10','11']\nfor bits in two_bits: \n  ar = QuantumRegister(2,'a')\n  qc = QuantumCircuit(ar)\n  qc.initialize(bits,ar)  \n  state1 = Statevector.from_instruction(qc)\n  print('='*75,'\\nBelow is for qubits: q0 =',bits[0],'; q1 =',bits[1])  \n  display(array_to_latex(state1, prefix='\\\\text{Statevector before QFT: }'))\n  display(state1.draw('bloch'))\n  qc.h(1)\n  qc.cp(pi/2, 0, 1)\n  qc.h(0)\n  qc.swap(0,1)\n  state2 = Statevector.from_instruction(qc)\n  #print('Below is the state after QFT')\n  display(array_to_latex(state2, prefix='\\\\text{Statevector after QFT: }'))  \n  display(state2.draw('bloch'))\n</pre> #Program 7.3 Apply QFT to qubit with various initial state from qiskit import QuantumRegister, QuantumCircuit from qiskit.quantum_info import Statevector from qiskit.visualization import array_to_latex from math import pi two_bits = ['00','01','10','11'] for bits in two_bits:    ar = QuantumRegister(2,'a')   qc = QuantumCircuit(ar)   qc.initialize(bits,ar)     state1 = Statevector.from_instruction(qc)   print('='*75,'\\nBelow is for qubits: q0 =',bits[0],'; q1 =',bits[1])     display(array_to_latex(state1, prefix='\\\\text{Statevector before QFT: }'))   display(state1.draw('bloch'))   qc.h(1)   qc.cp(pi/2, 0, 1)   qc.h(0)   qc.swap(0,1)   state2 = Statevector.from_instruction(qc)   #print('Below is the state after QFT')   display(array_to_latex(state2, prefix='\\\\text{Statevector after QFT: }'))     display(state2.draw('bloch')) <pre>=========================================================================== \nBelow is for qubits: q0 = 0 ; q1 = 0\n</pre>  $$ \\text{Statevector before QFT: } \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0  \\\\  \\end{bmatrix} $$   $$ \\text{Statevector after QFT: } \\begin{bmatrix} \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2}  \\\\  \\end{bmatrix} $$  <pre>=========================================================================== \nBelow is for qubits: q0 = 0 ; q1 = 1\n</pre>  $$ \\text{Statevector before QFT: } \\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0  \\\\  \\end{bmatrix} $$   $$ \\text{Statevector after QFT: } \\begin{bmatrix} \\frac{1}{2} &amp; \\frac{i}{2} &amp; - \\frac{1}{2} &amp; - \\frac{i}{2}  \\\\  \\end{bmatrix} $$  <pre>=========================================================================== \nBelow is for qubits: q0 = 1 ; q1 = 0\n</pre>  $$ \\text{Statevector before QFT: } \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0  \\\\  \\end{bmatrix} $$   $$ \\text{Statevector after QFT: } \\begin{bmatrix} \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2}  \\\\  \\end{bmatrix} $$  <pre>=========================================================================== \nBelow is for qubits: q0 = 1 ; q1 = 1\n</pre>  $$ \\text{Statevector before QFT: } \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1  \\\\  \\end{bmatrix} $$   $$ \\text{Statevector after QFT: } \\begin{bmatrix} \\frac{1}{2} &amp; - \\frac{i}{2} &amp; - \\frac{1}{2} &amp; \\frac{i}{2}  \\\\  \\end{bmatrix} $$  In\u00a0[4]: Copied! <pre>#Program 7.4 Define funciton to build n-qubit QFT quantum circuit\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom math import pi\ndef qft(n):\n  ar = QuantumRegister(n,'a')\n  qc = QuantumCircuit(ar)\n  for hbit in range(n-1,-1,-1):\n    qc.h(hbit) \n    for cbit in range(hbit):\n      qc.cp(pi/2**(hbit-cbit), cbit, hbit)  \n  for bit in range(n//2):\n    qc.swap(bit,n-bit-1)  \n  return qc  \nfor i in range(1,5):\n  print('Below is the QFT circuit of',i,'qubit(s):') \n  display(qft(i).draw('mpl'))\n</pre> #Program 7.4 Define funciton to build n-qubit QFT quantum circuit from qiskit import QuantumRegister, QuantumCircuit from math import pi def qft(n):   ar = QuantumRegister(n,'a')   qc = QuantumCircuit(ar)   for hbit in range(n-1,-1,-1):     qc.h(hbit)      for cbit in range(hbit):       qc.cp(pi/2**(hbit-cbit), cbit, hbit)     for bit in range(n//2):     qc.swap(bit,n-bit-1)     return qc   for i in range(1,5):   print('Below is the QFT circuit of',i,'qubit(s):')    display(qft(i).draw('mpl')) <pre>Below is the QFT circuit of 1 qubit(s):\n</pre> <pre>Below is the QFT circuit of 2 qubit(s):\n</pre> <pre>Below is the QFT circuit of 3 qubit(s):\n</pre> <pre>Below is the QFT circuit of 4 qubit(s):\n</pre> In\u00a0[5]: Copied! <pre>#Program 7.5 Define function to build n-qubit IQFT quantum circuit\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom math import pi\ndef iqft(n):\n  br = QuantumRegister(n,'b')\n  qc = QuantumCircuit(br)\n  for sbit in range(n//2):       #sbit: for swap qubit\n    qc.swap(sbit,n-sbit-1)  \n  for hbit in range(0,n,1):      #hbit: for h-gate qubit\n    for cbit in range(hbit-1,-1,-1):   #cbit: for count qubit\n      qc.cp(-pi/2**(hbit-cbit), cbit, hbit)  \n    qc.h(hbit) \n#  qc.name = \"IQFT\"  \n  return qc\nfor i in range(1,5):\n  print('Below is the IQFT circuit of',i,'qubit(s):') \n  display(iqft(i).draw('mpl'))\n</pre> #Program 7.5 Define function to build n-qubit IQFT quantum circuit from qiskit import QuantumRegister, QuantumCircuit from math import pi def iqft(n):   br = QuantumRegister(n,'b')   qc = QuantumCircuit(br)   for sbit in range(n//2):       #sbit: for swap qubit     qc.swap(sbit,n-sbit-1)     for hbit in range(0,n,1):      #hbit: for h-gate qubit     for cbit in range(hbit-1,-1,-1):   #cbit: for count qubit       qc.cp(-pi/2**(hbit-cbit), cbit, hbit)       qc.h(hbit)  #  qc.name = \"IQFT\"     return qc for i in range(1,5):   print('Below is the IQFT circuit of',i,'qubit(s):')    display(iqft(i).draw('mpl')) <pre>Below is the IQFT circuit of 1 qubit(s):\n</pre> <pre>Below is the IQFT circuit of 2 qubit(s):\n</pre> <pre>Below is the IQFT circuit of 3 qubit(s):\n</pre> <pre>Below is the IQFT circuit of 4 qubit(s):\n</pre> In\u00a0[6]: Copied! <pre>#Program 7.6 Apply QFT and then IQFT to qubit\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info import Statevector\nqc = QuantumCircuit(4)\nqc.initialize('1011',range(4))\nstate0 = Statevector.from_instruction(qc)\nqc.append(qft(4).to_gate(label='QFT'),range(4))\nstate1 = Statevector.from_instruction(qc)\nqc.append(iqft(4).to_gate(label='IQFT'),range(4))\nstate2 = Statevector.from_instruction(qc)\ndisplay(qc.draw('mpl'))\nprint('Statevector before QFT:')\ndisplay(state0.draw('bloch'))\nprint('Statevector after QFT:')\ndisplay(state1.draw('bloch'))\nprint('Statevector after IQFT:')\ndisplay(state2.draw('bloch'))\n</pre> #Program 7.6 Apply QFT and then IQFT to qubit from qiskit import QuantumCircuit from qiskit.quantum_info import Statevector qc = QuantumCircuit(4) qc.initialize('1011',range(4)) state0 = Statevector.from_instruction(qc) qc.append(qft(4).to_gate(label='QFT'),range(4)) state1 = Statevector.from_instruction(qc) qc.append(iqft(4).to_gate(label='IQFT'),range(4)) state2 = Statevector.from_instruction(qc) display(qc.draw('mpl')) print('Statevector before QFT:') display(state0.draw('bloch')) print('Statevector after QFT:') display(state1.draw('bloch')) print('Statevector after IQFT:') display(state2.draw('bloch')) <pre>Statevector before QFT:\n</pre> <pre>Statevector after QFT:\n</pre> <pre>Statevector after IQFT:\n</pre> In\u00a0[7]: Copied! <pre>#Program 7.7 Use QPE to estimate phase of S-gate\nfrom qiskit import QuantumRegister, QuantumCircuit, ClassicalRegister, execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nfrom math import pi\ncount_no = 2 #the number of count qubits\ncountreg = QuantumRegister(count_no,'count')\npsireg = QuantumRegister(1,'psi')\ncreg = ClassicalRegister(count_no,'c')                     \nqc = QuantumCircuit(countreg,psireg,creg)\nfor countbit in range(count_no):\n  qc.h(countbit)\nqc.x(psireg)\nrepeat = 1\nfor countbit in range(count_no):\n  for r in range(repeat):\n    qc.cp(pi/2,countbit,psireg)\n  repeat *= 2\nqc.barrier()\nfor sbit in range(count_no//2):       #sbit: for swap qubit\n  qc.swap(sbit,count_no-sbit-1)  \nfor hbit in range(0,count_no,1):      #hbit: for h-gate qubit\n  for cbit in range(hbit-1,-1,-1):    #cbit: for count qubit\n    qc.cp(-pi/2**(hbit-cbit), cbit, hbit)  \n  qc.h(hbit) \nqc.barrier()\nqc.measure(range(count_no),range(count_no))  \ndisplay(qc.draw('mpl'))\nsim = AerSimulator()\njob=execute(qc, backend=sim, shots=1000)\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(\"Total counts for qubit states are:\",counts)\nplot_histogram(counts)\n</pre> #Program 7.7 Use QPE to estimate phase of S-gate from qiskit import QuantumRegister, QuantumCircuit, ClassicalRegister, execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram from math import pi count_no = 2 #the number of count qubits countreg = QuantumRegister(count_no,'count') psireg = QuantumRegister(1,'psi') creg = ClassicalRegister(count_no,'c')                      qc = QuantumCircuit(countreg,psireg,creg) for countbit in range(count_no):   qc.h(countbit) qc.x(psireg) repeat = 1 for countbit in range(count_no):   for r in range(repeat):     qc.cp(pi/2,countbit,psireg)   repeat *= 2 qc.barrier() for sbit in range(count_no//2):       #sbit: for swap qubit   qc.swap(sbit,count_no-sbit-1)   for hbit in range(0,count_no,1):      #hbit: for h-gate qubit   for cbit in range(hbit-1,-1,-1):    #cbit: for count qubit     qc.cp(-pi/2**(hbit-cbit), cbit, hbit)     qc.h(hbit)  qc.barrier() qc.measure(range(count_no),range(count_no))   display(qc.draw('mpl')) sim = AerSimulator() job=execute(qc, backend=sim, shots=1000) result = job.result() counts = result.get_counts(qc) print(\"Total counts for qubit states are:\",counts) plot_histogram(counts) <pre>Total counts for qubit states are: {'01': 1000}\n</pre> Out[7]: In\u00a0[8]: Copied! <pre>#Program 7.8 Classical Shor Algorithm\nfrom random import randint\nfrom math import gcd\ndef period_finding(a,N):\n  for r in range(1,N):\n    if (a**r) % N == 1:\n      return r\ndef shor_alg(N):\n  while True:\n    a=randint(2,N-1)\n    g=gcd(a,N)\n    if g!=1:\n      p=g\n      q=N//g\n      return p,q\n    else:\n      r=period_finding(a,N)  \n      if r % 2 != 0:\n        continue\n      elif a**(r//2) % N == -1 % N:\n        continue\n      else:\n        p=gcd(a**(r//2)+1,N)\n        if p==1 or p==N:\n          p=gcd(a**(r//2)-1,N)\n        q=N//p\n      return p,q\nfor N in [15, 21, 35, 913, 2257, 10999]:\n  print(f'Factors of {N}: {shor_alg(N)}')\n</pre> #Program 7.8 Classical Shor Algorithm from random import randint from math import gcd def period_finding(a,N):   for r in range(1,N):     if (a**r) % N == 1:       return r def shor_alg(N):   while True:     a=randint(2,N-1)     g=gcd(a,N)     if g!=1:       p=g       q=N//g       return p,q     else:       r=period_finding(a,N)         if r % 2 != 0:         continue       elif a**(r//2) % N == -1 % N:         continue       else:         p=gcd(a**(r//2)+1,N)         if p==1 or p==N:           p=gcd(a**(r//2)-1,N)         q=N//p       return p,q for N in [15, 21, 35, 913, 2257, 10999]:   print(f'Factors of {N}: {shor_alg(N)}') <pre>Factors of 15: (5, 3)\nFactors of 21: (3, 7)\nFactors of 35: (5, 7)\nFactors of 913: (83, 11)\nFactors of 2257: (37, 61)\nFactors of 10999: (17, 647)\n</pre> In\u00a0[9]: Copied! <pre>#Program 7.9 Define function to build modular exponentiation quantum circuit\nfrom qiskit import QuantumRegister, QuantumCircuit\ndef qc_mod15(a, power, show=False):\n  assert a in [2,4,7,8,11,13], 'Invalid value of argument a:'+str(a)\n  qrt = QuantumRegister(4,'target')\n  U = QuantumCircuit(qrt)        \n  for i in range(power):\n    if a in [2,13]:\n      U.swap(0,1)\n      U.swap(1,2)\n      U.swap(2,3)\n    if a in [7,8]:\n      U.swap(2,3)\n      U.swap(1,2)\n      U.swap(0,1)\n    if a in [4, 11]:\n      U.swap(1,3)\n      U.swap(0,2)\n    if a in [7,11,13]:\n      for j in range(4):\n        U.x(j)\n  if show:\n    print('Below is the circuit of U of '+f'\"{a}^{power} mod 15\":') \n    display(U.draw('mpl'))\n  U = U.to_gate()\n  U.name = f'{a}^{power} mod 15'\n  C_U = U.control()\n  return C_U\npower_arg=2\nfor a_arg in [2,4,7,8,11,13]:\n  qrc = QuantumRegister(1,'control')\n  qrt = QuantumRegister(4,'target')\n  qc = QuantumCircuit(qrc,qrt)\n  qc.append(qc_mod15(a_arg, power_arg, show=True),[0,1,2,3,4])\n  print('Below is the circuit of controlled U of '+f'\"{a_arg}^{power_arg} mod 15\":')\n  display(qc.draw('mpl'))\n</pre> #Program 7.9 Define function to build modular exponentiation quantum circuit from qiskit import QuantumRegister, QuantumCircuit def qc_mod15(a, power, show=False):   assert a in [2,4,7,8,11,13], 'Invalid value of argument a:'+str(a)   qrt = QuantumRegister(4,'target')   U = QuantumCircuit(qrt)           for i in range(power):     if a in [2,13]:       U.swap(0,1)       U.swap(1,2)       U.swap(2,3)     if a in [7,8]:       U.swap(2,3)       U.swap(1,2)       U.swap(0,1)     if a in [4, 11]:       U.swap(1,3)       U.swap(0,2)     if a in [7,11,13]:       for j in range(4):         U.x(j)   if show:     print('Below is the circuit of U of '+f'\"{a}^{power} mod 15\":')      display(U.draw('mpl'))   U = U.to_gate()   U.name = f'{a}^{power} mod 15'   C_U = U.control()   return C_U power_arg=2 for a_arg in [2,4,7,8,11,13]:   qrc = QuantumRegister(1,'control')   qrt = QuantumRegister(4,'target')   qc = QuantumCircuit(qrc,qrt)   qc.append(qc_mod15(a_arg, power_arg, show=True),[0,1,2,3,4])   print('Below is the circuit of controlled U of '+f'\"{a_arg}^{power_arg} mod 15\":')   display(qc.draw('mpl')) <pre>Below is the circuit of U of \"2^2 mod 15\":\n</pre> <pre>Below is the circuit of controlled U of \"2^2 mod 15\":\n</pre> <pre>Below is the circuit of U of \"4^2 mod 15\":\n</pre> <pre>Below is the circuit of controlled U of \"4^2 mod 15\":\n</pre> <pre>Below is the circuit of U of \"7^2 mod 15\":\n</pre> <pre>Below is the circuit of controlled U of \"7^2 mod 15\":\n</pre> <pre>Below is the circuit of U of \"8^2 mod 15\":\n</pre> <pre>Below is the circuit of controlled U of \"8^2 mod 15\":\n</pre> <pre>Below is the circuit of U of \"11^2 mod 15\":\n</pre> <pre>Below is the circuit of controlled U of \"11^2 mod 15\":\n</pre> <pre>Below is the circuit of U of \"13^2 mod 15\":\n</pre> <pre>Below is the circuit of controlled U of \"13^2 mod 15\":\n</pre> In\u00a0[10]: Copied! <pre>#Program 7.10: Define quantum period finding function with N=15\nfrom qiskit import QuantumRegister,ClassicalRegister,QuantumCircuit\ndef qpf15(count_no,a):\n  qrc = QuantumRegister(count_no,'count')\n  qry = QuantumRegister(4,'y') #for input of qc_mod15 gate \n  clr = ClassicalRegister(count_no,'c')  \n  qc = QuantumCircuit(qrc, qry, clr) \n  for cbit in range(count_no):\n    qc.h(cbit)\n  qc.x(qry[0]) #Set the input of qc_mod15 as |1&gt; with y0 as LSB\n  for cbit in range(count_no):   #Add controlled-qc_mod15 gates\n    qc.append(qc_mod15(a, 2**cbit), [cbit] + list(range(count_no, count_no+4)))\n  qc.append(iqft(count_no).to_gate(label='IQFT'), range(count_no))\n  qc.measure(range(count_no), range(count_no))\n  return qc\ndisplay(qpf15(count_no=3,a=13).draw('mpl'))\n</pre> #Program 7.10: Define quantum period finding function with N=15 from qiskit import QuantumRegister,ClassicalRegister,QuantumCircuit def qpf15(count_no,a):   qrc = QuantumRegister(count_no,'count')   qry = QuantumRegister(4,'y') #for input of qc_mod15 gate    clr = ClassicalRegister(count_no,'c')     qc = QuantumCircuit(qrc, qry, clr)    for cbit in range(count_no):     qc.h(cbit)   qc.x(qry[0]) #Set the input of qc_mod15 as |1&gt; with y0 as LSB   for cbit in range(count_no):   #Add controlled-qc_mod15 gates     qc.append(qc_mod15(a, 2**cbit), [cbit] + list(range(count_no, count_no+4)))   qc.append(iqft(count_no).to_gate(label='IQFT'), range(count_no))   qc.measure(range(count_no), range(count_no))   return qc display(qpf15(count_no=3,a=13).draw('mpl')) In\u00a0[11]: Copied! <pre>#Program 7.11 Run quantum period finding function with N=15\nfrom qiskit import execute\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nfrom fractions import Fraction\nsim = AerSimulator()\ncount_no=3\ncir = qpf15(count_no=count_no,a=13)\njob=execute(cir, backend=sim, shots=1000)\nresult = job.result()\ncounts = result.get_counts(cir)\ndisplay(plot_histogram(counts))\nprint('Total counts for qubit states are:',counts,'\\n')\nprint('%10s %10s %10s %10s %10s' % ('Binary','Decimal','Phase','Fraction','Period'))  \nfor akey in counts.keys():\n  dec=int(akey,base=2)\n  phase=dec/(2**count_no)\n  frac=Fraction(phase).limit_denominator(15)\n  period=frac.denominator\n  print('%10s %10d %10f %10s %10d' % (akey,dec,phase,frac,period))\n</pre> #Program 7.11 Run quantum period finding function with N=15 from qiskit import execute from qiskit.providers.aer import AerSimulator from qiskit.visualization import plot_histogram from fractions import Fraction sim = AerSimulator() count_no=3 cir = qpf15(count_no=count_no,a=13) job=execute(cir, backend=sim, shots=1000) result = job.result() counts = result.get_counts(cir) display(plot_histogram(counts)) print('Total counts for qubit states are:',counts,'\\n') print('%10s %10s %10s %10s %10s' % ('Binary','Decimal','Phase','Fraction','Period'))   for akey in counts.keys():   dec=int(akey,base=2)   phase=dec/(2**count_no)   frac=Fraction(phase).limit_denominator(15)   period=frac.denominator   print('%10s %10d %10f %10s %10d' % (akey,dec,phase,frac,period))   <pre>Total counts for qubit states are: {'100': 257, '110': 233, '000': 252, '010': 258} \n\n    Binary    Decimal      Phase   Fraction     Period\n       100          4   0.500000        1/2          2\n       110          6   0.750000        3/4          4\n       000          0   0.000000          0          1\n       010          2   0.250000        1/4          4\n</pre>"},{"location":"quantum_computing/Code-Ch7/#7","title":"\u7b2c7\u7ae0\u539f\u59cb\u7a0b\u5f0f\u78bc:\u00b6","text":""}]}